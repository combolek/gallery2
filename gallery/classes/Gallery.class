<?php
/*
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2002 Bharat Mediratta
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

/**
 * Global storage container and utility class for Gallery
 *
 * This is a container for global information required for gallery
 * operation, such as configuration, session, user, etc.  It also
 * serves as the GalleryItem manager.  All requests for GalleryItems
 * should go through this class so that they can be cached and shared.
 *
 * @version $Id$
 * @package GalleryCore
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class Gallery {

    /*
     * ****************************************
     *                 Members
     * ****************************************
     */

    /**
     * The id of the root AlbumItem in the Gallery
     *
     * @var	string
     */
    var $_rootAlbumItemId;

    /**
     * The id of the active user
     *
     * @var	int
     */
    var $_activeUserId;

    /**
     * Storage for all configuration variables, set in config.php.
     * The values contained here can't be modified.  Well, they
     * can be modified but they can't be saved so it's not a good
     * idea.  
     *
     * @var	object	GalleryMap	$_config;
     */
    var $_config;

    /**
     * An instance of the user database class
     *
     * @var	object	UserDatabase	$_userDatabase;
     */
    var $_userDatabase;

    /**
     * The current GalleryImageToolkit
     *
     * @var object	GalleryImageToolkit	$_imageToolkit;
     */
    var $_imageToolkit;

    /**
     * Storage for all session variables.  Contains an instance
     * of the GalleryMap class.
     *
     * @var	object	GalleryMap	 $_session;
     */
    var $_session;

    /**
     * The backend persistent store for the Gallery class
     *
     * @access private
     * @var	object	GalleryStorage	 $_storage;
     */
    var $_storage;

    /**
     * A GalleryLock containing a Local lockset
     *
     * @access private
     * @var	object	GalleryLock	$_lockLocal;
     */
    var $_lockLocal;

    /**
     * A GalleryLock containing the World lock
     *
     * @access private
     * @var	object	GalleryLock	$_lockWorld;
     */
    var $_lockWorld;

    /*
     * ****************************************
     *                 Methods
     * ****************************************
     */

    /**
     * Return the id of the GalleryItem associated with the path provided
     *
     * Return the id associated with the given path. Example path:
     * "/birthdays/fred" .. this is the "fred" item in the "birthdays"
     * item.  It doesn't really matter what types of items these are, as
     * long as the path is legitimate.
     *
     * @access public
     * @param string the path to a GalleryItem
     * @return int the id of the GalleryItem (or null)
     */
    function getIdByPath($path) {
	return $this->_storage->getIdByPath($path);
    }

    /**
     * Get the GalleryItem for the id provided
     *
     * Return the GalleryItem associated with this id.  Note  
     * that this returns the unique object itself, not a copy.
     * This means that you can change/save it.
     *
     * @access public
     * @param int the id of the GalleryItem
     * @return object GalleryItem the GalleryItem
     */
    function &getItemById($id) {
	return $this->_storage->getItemById($path);
    }

    /**
     * Get the DataContainer for the id provided
     *
     * Return the DataContainer associated with this id.  Note  
     * that this returns the unique object itself, not a copy.
     * This means that you can change/save it.
     *
     * @access public
     * @param int the id of the item
     * @return object GalleryItem the GalleryItem
     */
    function &getDataContainerById($id) {
	return $this->_storage->getDataContainerById($path);
    }

    /**
     * Search this item to see if it contains the search string.
     *
     * If this item has sub-items, search them also.
     *
     * @access public
     * @param string the search criteria
     * @return array a list of of GalleryItem ids
     */
    function search($criteria) {
	// XXX: should this method live in Gallery or in GalleryItem?
	// If we're aiming for speed, then we'd really like to do one search
	// across the entire GalleryItem database.  But, that won't let us
	// restrict the search to just one branch of the tree.  For now let's
	// leave it here and then perhaps later we can introduce the concept of
	// a "narrower" search
    }

    /**
     * Return the id of the root GalleryItem
     *
     * The root GalleryItem should be an AlbumItem
     *
     * @access public
     * @return int the id of the root album
     */
    function getRootAlbumItemId() {
	return $this->_rootAlbumItemId;
    }

    /**
     * Set the id of the root GalleryItem
     *
     * The root GalleryItem should be an AlbumItem.
     *
     * @access public
     * @param int the id of the GalleryItem
     */
    function setRootAlbumItemId($id) {
	assert(!empty($id));
	$this->_rootAlbumItemId = $id;
    }

    /**
     * Get the Id of the active user
     *
     * The active user is the user who is logged on in this 
     * session.
     * 
     * @access public
     * @return int the id of the current User.
     */
    function getActiveUserId() {
	return $this->_activeUserId;
    }

    /**
     * Set the id of the active user
     *
     * The active user is the user who is logged on in this 
     * session.
     * 
     * @param int the id of the current User.
     * @access public
     */
    function setActiveUserId($id) {
	assert(!empty($id));
	$this->_activeUserId = $id;
    }
    
    /**
     * Get the user database 
     *
     * Return a reference to the instance of the active
     * GalleryUserDatabase class.
     * 
     * @access public
     * @return object GalleryUserDatabase the active user database
     */
    function &getUserDatabase() {
	return $this->_userDatabase;
    }

    /**
     * Set the user database 
     *
     * Assign a reference to the instance of the active
     * GalleryUserDatabase class.
     * 
     * @param object GalleryUserDatabase the active user database
     * @access public
     */
    function setUserDatabase(&$userDatabase) {
	$this->_userDatabase =& $userDatabase;
    }

    /**
     * Get the image toolkit
     *
     * Return a reference to the instance of the active
     * GalleryImageToolkit class.
     * 
     * @access public
     * @return object GalleryImageToolkit the active image toolkit
     */
    function &getImageToolkit() {
	return $this->_imageToolkit;
    }

    /**
     * Set the image toolkit
     *
     * Assign a reference to the instance of the active
     * GalleryImageToolkit class.
     * 
     * @param object GalleryImageToolkit the active image toolkit
     * @access public
     */
    function getImageToolkit(&$imageToolkit) {
	$this->_imageToolkit =& $imageToolkit;
    }

    /**
     * Get a copy of the Gallery configuration settings
     *
     * Return a copy of the GalleryMap config instance.  Do not
     * change the copy, as the changes will be lost.  The value of
     * this config object is generated in config.php
     * 
     * @access public
     * @return object GalleryMap the Gallery config map
     */
    function getConfig() {
	return $this->_config;
    }

    /**
     * Set a copy of the Gallery configuration settings
     *
     * Assign a reference to a GalleryMap config instance.
     * 
     * @param object GalleryMap the Gallery config map
     * @access public
     */
    function setConfig(&$config) {
	$this->_config =& $config;
    }

    /**
     * Get the Gallery session object.
     *
     * Return a reference to the unique Gallery session object
     * (implemented as an instance of the GalleryMap class).  Any
     * changes made to this object will be saved in the session.
     * 
     * @access public
     * @return object GalleryMap the Gallery session map
     */
    function &getSession() {
	return $this->_session;
    }

    /**
     * Get the Gallery session object.
     *
     * Assign a reference to the unique Gallery session object
     * (implemented as an instance of the GalleryMap class).
     * 
     * @param object GalleryMap the Gallery session map
     * @access public
     */
    function &setSession($session) {
	$this->_session =& $session;
    }

    /**
     * Lock the given GalleryNucleus instances.
     *
     * Use the active locking mechanism to lock the given GalleryNucleus instances.
     * 
     * Use register_shutdown_function() to register the unlockLocal() method so
     * that we can be sure that we won't accidentally leave the instances
     * locked.
     * 
     * @access public
     * @param array the GalleryNucleus' to be locked 
     * @param integer how long to wait for the lock before giving up
     * @return int a status code
     */
    function lockLocal($array, $timeout=2) {
	/*
	 * If we already have a lock, fail.
	 */
	assert(empty($this->_lockWorld) && empty($this->_lockLocal));

	/*
	 * If we don't have a lock, get one and register it with the
	 * end-of-session handler so that we can be sure that it goes away.
	 */
	$this->_lockLocal = $this->_storage->newLock($array, $timeout);
	if (empty($this->_lockLocal)) {
	    return ERROR | ERROR_LOCK_IN_USE;
	}

	register_shutdown_function(array($this->_lockLocal, "unlock"));
	
	/*
	 * After we acquire the lock, refresh all the locked objects so that we
	 * know they are up to date before doing any operations.
	 *
	 * XXX: This still doesn't solve concurrency issues -- perhaps we
	 * should change this so that we fail if one of the objects *isn't* up
	 * to date, allowing the application code to let the user retry.
	 */
	for ($i = 0; $i < length($array); $i++) {
	    $array[$i]->refresh();
	}

	return SUCCESS;
    }

    /**
     * Release the local lock
     *
     * Save all the instances that were covered by the local lock.
     *
     * @access public
     */
    function unlockLocal() {
	assert(!empty($this->_lockLocal));
	$this->_lockLocal->unlock();
    }

    /**
     * Lock the entire Gallery
     *
     * Use the active locking mechanism to lock the entire Gallery.  Then,
     * traverse the tree and refresh any objects that we have in memory.  The
     * result of this call is that the entire tree is in sync with the
     * persistent store, and until unlockWorld is called, no one else can
     * change it.
     *
     * Use register_shutdown_function() to register the unlockWorld() method so
     * that we can be sure that we won't accidentally leave the world locked.
     * 
     * @access public
     * @param integer how long to wait for the lock before giving up
     * @return int a status code
     */
    function lockWorld($timeout=10) {
	/*
	 * If we already have a lock, fail.
	 */
	assert(empty($this->_lockWorld) && empty($this->_lockLocal));
	
	/*
	 * If we don't have a lock, get one and register it with the
	 * end-of-session handler so that we can be sure that it goes away.
	 */
	$this->_lockWorld = $this->_storage->newLock($array, $timeout);
	if (empty($this->_lockWorld)) {
	    return ERROR | ERROR_LOCK_IN_USE;
	}

	/*
	 * After we acquire the lock, refresh all the locked objects so that we
	 * know they are up to date before doing any operations.
	 *
	 * XXX: This still doesn't solve concurrency issues -- perhaps we
	 * should change this so that we fail if one of the objects *isn't* up
	 * to date, allowing the application code to let the user retry.
	 */
	for ($i = 0; $i < length($array); $i++) {
	    $array[$i]->refresh();
	}
    }

    /**
     * Release the World lock
     *
     * Traverse the tree and save any objects that need saving.
     *
     * @access public
     */
    function unlockWorld() {
	assert(!empty($this->_lockWorld));
	$this->_lockWorld->unlock();
    }

    /**
     * Return a reference to the implementation of the GalleryStorage class
     *
     * @access public
     */
    function &getStorage() {
	return $this->_storage;
    }

    /**
     * Set a new GalleryStorage instance.
     *
     * Accept a new instance of GalleryStorage and use it for all further
     * storage requests.
     *
     * @access public
     */
    function &setStorage(&$storage) {
	$this->_storage =& $storage;
    }
}
?>
