<?xml version="1.0" encoding="ISO-8859-1"?>
<sect1 id="gallery2.dev-guide">
 <title>Gallery 2.0 Developer's Guide</title> 
 
 <sect2 id="gallery2.dev-guide.intro">
  <title>
   Introduction 
  </title>
  <sect3>
   <title>
    Goals
   </title>
   <para>
    Gallery 2.x is designed to be the next generation category killer of
    open source photo presentation software.  With this product, users can
    quickly and easily publish their media (photos, movies, audio clips,
    etc).  It is reliable, scalable, flexible, modular, intuitive,
    localizable, portable and easily customizable.        
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Reliable
     </para>
     <para>
      G2 will be reliable at all times.  It will never lose your data, ever.
     </para>
    </listitem>
    <listitem>
     <para>
      Scalable
     </para>
     <para>
      G2 will scale to manage hundreds of thousands of images with
      little or no degradation in its processing speed.  Viewing an
      album will be just as fast if it contains 10 items or 10000
      items.
     </para>
    </listitem>
    <listitem>
     <para>
      Flexible
     </para>
     <para>
      The G2 layout and theme system will allow you to present
      G2 in many different ways to suite your particular needs,
      from family websites to corporate employee databases to
      merchant catalogs.
     </para>
    </listitem>
    <listitem>
     <para>
      Modular
     </para>
     <para>
      The G2 module API provides a mechanism for developers to
      add new functionality quickly and easily.  These new
      modules have all the power of existing ones and will
      integrate seamlessly into the product.
     </para>
    </listitem>
    <listitem>
     <para>
      Localizable
     </para>
     <para>
      G2 will separate out all user-visible content such that it
      can be readily localized into any language.
     </para>
    </listitem>
    <listitem>
     <para>
      Intuitive
     </para>
     <para>
      G2 will be intuitively easy to install and use.  Users who
      browse G2 will have no problem understanding how to
      navigate the product and use it effectively.
     </para>
    </listitem>
    <listitem>
     <para>
      Customizable
     </para>
     <para>
      The styles and layouts used in G2 will be separated from
      the code so that they can be easily modified by the G2
      administrator.
     </para>
    </listitem>
    <listitem>
     <para>
      Portable
     </para>
     <para>
      G2 will work on any PHP platform and support a wide range of data
      processors (eg, image toolkits) and all the popular database
      solutions.
     </para>
    </listitem>
   </itemizedlist>
  </sect3>
  <sect3>
   <title>
    Brief History
   </title>
   <para>
    In the beginning there was Gallery 1.x.  Actually, in the
    beginning Bharat bought a digital camera and thought "wouldn't
    it be nice if I could put these photos somewhere."  But when
    Gallery 1.x came into being, the developers had no idea what
    they were doing.  They didn't know PHP very well, didn't
    understand the importance of separating code from content,
    didn't have a whole lot of database experience, you get the
    idea.  So they started by just writing something that worked,
    and then slowly building upon it.  The end result is Gallery
    1.x which works quite nicely but internally is a bit of a
    mess.
   </para>
   <para>
    When the developers realized that Gallery was going to be a
    useful and successful product, they were faced with a choice:
    fix all the various problems with Gallery 1.x, or start from
    scratch and build Gallery 2.x which does everything the right
    way and doesn't have all the various problems that abound in
    Gallery 1.x.  After much discussion, they decided that only a
    complete rewrite would fix some of the fundamental problems
    with Gallery 1.x and G2 was born.
   </para>
  </sect3>
 </sect2>
 <sect2 id="gallery2.dev-guide.concepts">
  <title>
   Concepts
  </title>
  <sect3>
   <title>
    Test Driven Development
   </title>
   <para>
    Writing a application that must run on many different
    platforms, works with multiple databases and is based on
    emerging technologies can be very challenging. Especially when
    the development is distributed and has been in progress over a
    long period of time. As we've worked on Gallery2 we've found
    issues with the design and implementation that make us want to
    rework large parts of the system. However, we fear making
    large changes because even though G2 is modular and well
    written there are still interdependencies between different
    parts of the system and there's the chance that we're breaking
    something critical. After all, how do we have to know that our
    change is going to work on all of our platforms and databases
    without doing a lot of exhaustive and manual testing? This can
    be daunting and it tends to impose a conservative mindset
    where we fear to enact change because we know that we won't be
    able to find out the consequences until its too late. That is
    unacceptable; we must be willing to make large changes or
    we'll get stuck with an inferior design.
   </para>
   <para>
    Enter Test Driven Development.
   </para>
   <para>
    This is a strategy whereby every new bit of functionality
    starts its life as a test. We envision the feature and then
    write a test that will only succeed when the feature is
    complete. Initially when we run the test it fails because we
    haven't written the feature yet. Then we go and write the
    feature until it satisfies the test. If we think of a new
    twist or restrictrion on the feature then we write a new test
    and then keep working on the code until that test passes
    also. Pretty soon we have a very large set of tests, and all
    of our code is getting tested regularly. If we find something
    that doesn't look right, or can be combined with other code we
    can feel free to make as many small or large changes as we
    want, as long as when we check the changes in the tests still
    run. Find a bug? Write a test that fails until the bug is
    fixed. Want to add a feature? Write a test first. Code running
    slow? Refactor and optimize at will as long as the tests still
    run. Want to know if your code is going to work on a different
    platform? Go to that platform and run the tests. Find a bug on
    that platform? Write a test to expose the bug, fix the bug so
    that the test works, check it all in and then go and run the
    tests on the first platform.
   </para>
   <para>
    G2 uses a system called phpunit to do unit testing and at the
    time of this writing has about 150 tests covering almost all
    of the core and part of the core feature set. We started doing
    test driven development after writing the bulk of the code so
    we've been playing catchup to write tests to cover all the
    stuff we've already written. Soon we'll have written tests for
    all existing functionality, and all new functionality will
    stem from tests. If you want to see what the test suite looks
    like, install G2 and browse to
    gallery2/setup/phpunit/index.php
   </para>
   <para>
    Test Driven Development is not our idea. It stems from a
    methodology called Extreme Programming. Bharat learned about
    Extreme Programming while doing development on SourceForge,
    grew enamored of it and decided that while not all principles
    could be applied to an open source project like Gallery, at
    least some of them were of tremendous value. For more
    information about Extreme Programming read these links:
    <itemizedlist>
     <listitem>
      <para>
       <ulink url="http://www.google.com/search?q=extreme+programming">
        <citetitle>
         Extreme Programming Google Links
        </citetitle>
       </ulink>
      </para>
     </listitem>
     <listitem>
      <para>
       <ulink url="http://junit.sourceforge.net/doc/testinfected/testing.htm">
        <citetitle>
         Test Infected
        </citetitle>
       </ulink>
      </para>
     </listitem>
     <listitem>
      <para>
       <ulink url="http://www.artima.com/intv/testdriven4.html">
        <citetitle>
         Test Driven Development
        </citetitle>
       </ulink>
      </para>
     </listitem>
     <listitem>
      <para>
       <ulink url="http://www.xprogramming.com/xpmag/whatisxp.htm">
        <citetitle>
         What is Extreme Programming?
        </citetitle>
       </ulink>
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect3>
  <sect3>
   <title>
    Embedding Gallery in Other Applications
   </title>
   <para>
    Gallery is designed very specifically to manage your
    multimedia online.  It's not a content management system or a
    blog or a website editor.  However, there's no reason why
    Gallery can't be the multimedia management portion of a much
    larger system which does much more context content management
    or blogging, etc.  Many such systems focus on their core
    competency and provide a very weak multimedia management
    system.  Gallery is designed to work within those larger
    systems and provide the functionality that they lack.
   </para>
   <para>
    In order to make this process of embedding easier, Gallery is
    very careful about not polluting global namespaces.  Core
    classes, constants, database tables, etc are prefixed with
    different forms of "gallery" to identify them as separate from
    the outer program.
   </para>
   <para>
    How we actually go about embedding Gallery into another
    program depends heavily on which program we are going to work
    with.  For PHP CMS systems like PostNuke/PHP-Nuke, we will
    need to create a new entry point into G2 that replaces
    main.php. This new entry point will be PostNuke/PHP-Nuke
    specific and will give us a way to interoperate between the
    two.  Then we need to extend the database storage layer so
    that it understands that the user/group information is now
    stored in a different table/column arrangement so that our
    queries continue to function. Then we need disable certain
    functionality (like user management) and provide some new
    templates for the administration console so that we can tie
    the G2 site admin interface into the CMS' admin system.
   </para>
   <para>
    I'm envisioning shipping a snap-on pack for each CMS that
    converts your G2 install into one that works for the specific
    CMS. It'll work by adding new files/modules to the G2 install
    (but not replacing existing files).  This is in the
    speculative stage so no substantive work has been done on it
    yet.
   </para>
  </sect3>
  <sect3>
   <title>
    Redirect-On-Post
   </title>
   <para>
    One aggravating thing about may dynamic websites is the
    situation where you want to reload a page, but the page was
    created by a form submission and reloading the page will
    submit the form again which may do something you did not
    intend.  To avoid this problem, G2 will always redirect you to
    a new page after you successfully complete an operation.  If
    you do a form post and it *doesn't* do anything (ie, it gives
    you an error) it won't redirect since it's safe to reload that
    page again if you choose.  Of course, reloading that page will
    just give you the same error, but at least it won't cause any
    damage.
   </para>
  </sect3>
  <sect3>
   <title>
    Coding standards
   </title>
   <para>
    Clean code is important, especially when many developers are
    collaborating.  Read and obey the Gallery 2
    <ulink url="http://gallery.menalto.com/modules.php?op=modload&amp;name=GalleryDocs&amp;file=index&amp;req=viewarticle&amp;artid=19">
     Coding Standards
    </ulink>
    document
   </para>
  </sect3>
  <sect3>
   <title>
    Check all return codes
   </title>
   <para>
    Reliability is one of Gallery's fundamental goals.  The path
    to reliability is to religiously check every single return
    code and make sure that when something goes wrong we handle it
    in the most appropriate way.
   </para>
   <para>
    Sadly, PHP lacks exception handling which means that we have
    to comeup with our own way to check return values.  G2 has its
    own system for returning status values such that errors bubble
    up to the top and can be handled at every step of the way.  We
    build up a stack trace while handling these errors and this
    stack trace can be used to diagnose problems when they occur.
   </para>
   <para>
    Any method that can fail should return an instance of a
    GalleryStatus object.  In the case of a successful result, it
    should return:
    <programlisting>
     return GalleryStatus::success();
    </programlisting>
    Upon failure, it should return the appropriate error code along
    with the relevant file name and line number like this:
    <programlisting>
     return GalleryStatus::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__);
    </programlisting>
    The complete list of error codes can be found in the
    modules/core/GalleryStatus class.  The code that calls this method
    should check this error code and handle it properly:
    <programlisting>
     $ret = methodThatReturnsStatus();
     if ($ret->isError()) {
         return $ret->wrap(__FILE__, __LINE__);
     }
    </programlisting>
    Note that we tag on the file and line numbers when we return the
    status code.  This is how we build up the stack trace.  We follow
    the convention that all status codes are called
    <emphasis>$ret</emphasis>.  This is a good idea in case we wish to
    refactor this code later on; it'll make those lines easier to
    find.  Note also that if your method returns other values, it
    should return an array so that the first element can be a status
    code.
   </para>
  </sect3>
 </sect2>
 <sect2 id="gallery2.dev-guide.modules">
  <title>
   Modules
  </title>
  <para>
   Modules are where all of the Gallery functionality lives.  Even
   the core Gallery framework is a module.  Modules can be added and
   removed from the Gallery framework and each module can add
   virtually unlimited functionality.  Modules can use existing
   database tables, they can use APIs from other modules, they can
   introduce new item types into the gallery.  In short, they are
   where all functionality lives.
  </para>
  <sect3 id="gallery2.dev-guide.modules.layout">
   <title>
    Module Layout
   </title>
   <para>
    Modules only have one hard requirement, which is that you must
    have a module.inc file in the top level of the module directory.
    However, we do suggest a layout for your module files to make it
    consistent with the rest of the Gallery modules.
    <screen>
      module/
       <lineannotation>Views and Controllers</lineannotation>
       module.inc    <lineannotation>this is the only mandatory file</lineannotation>
       classes/
         GNUmakefile
         interfaces/
           GNUmakefile
           <lineannotation>generated entity and map interfaces</lineannotation>
         GalleryStorage/
           DatabaseStorage/
             schema/
               xml-src/
                 GNUmakefile
               platform/
                 GNUmakefile
                 mysql/
                   GNUmakefile
                   <lineannotation>MySQL specific SQL scripts</lineannotation>
                 postgres/
                   GNUmakefile
                   <lineannotation>PostgresQL specific SQL scripts</lineannotation>
       locale/
         GNUmakefile
         <lineannotation>a tree of generated gettext .mo files</lineannotation>
       po/
         GNUmakefile
         <lineannotation>hand written gettext .po translation files</lineannotation>
       templates/
         <lineannotation>Smarty template files </lineannotation>
       tests/
         data/
         <lineannotation>Data used by PHPUnit tests</lineannotation>
         phpunit/
         <lineannotation>PHPUnit tests</lineannotation>
    </screen>
    Several notes about this layout:
    <itemizedlist>
     <listitem>
      <para>
       The GNUmakefile files are used to create all generated files
       (like class interfaces, SQL scripts, translations, etc.).
       Typically you just need to copy the GNUmakefile from the same
       spot in an existing module (say the comment module, since it
       has all of them).  You shouldn't have to tweak the file at all
       if you put it into the same spot in your module.
      </para>
     </listitem>
     <listitem>
      <para>
       You only need to include the GalleryStorage/ tree if you're
       going to create database tables.  Gallery provides a way to
       create tables that work on any of our supported databases
       without you having to write the SQL yourself.  This is also a
       good idea because it will version these tables, install them
       for you and help the user through the upgrade process.  You're
       not <emphasis>required</emphasis> to do it this way but we
       strongly suggest it.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect3>
  <sect3 id="gallery2.dev-guide.modules.lifecycle">
   <title>
    Module Life Cycle
   </title>
   <para>
    Modules arrive in your Gallery either as part of the core Gallery
    package, or they're downloaded and unpacked into the modules
    directory.  In order to be used, a module must be installed, then
    activated via the Site Admin interface.  Each active module is
    loaded upon every request so that it has an opportunity to
    register factory implementations, views, event listeners, etc.
    We'll explain what all of those are in detail below.  Ultimately,
    a module can be deactivated and uninstalled via the Site Admin
    interface and then deleted from the modules directory.
   </para>
  </sect3>
  <sect3 id="gallery2.dev-guide.modules.components">
   <title>
    Module Components
   </title>
   <sect4>
    <title>
     module.inc
    </title>
    <para>
     All modules live within the modules/ directory inside the Gallery
     directory.  Each module must contain a file called "module.inc" at
     the top level which contains a PHP class that extends
     GalleryModule.  The GalleryModule class provides a very simple
     module implementation designed to be a framework that you can
     build on.  You must override some of the GalleryModule methods in
     your own module implementation to give it the behaviour that you
     want.  
     <itemizedlist>
      <listitem>
       <para>
        init()
       </para>
       <para>
        Do any initialization required for this module to run.  The
        init method is called on every active module on every request.
        You should not do anything heavy in this method if you can
        avoid it.  Typically you would register any GalleryFactory
        implementations (see below) at this time and load any helper
        classes that you now you'll need.  See the
        <emphasis>comment</emphasis> module for an example.
       </para>
      </listitem>
      <listitem>
       <para>
        install()
       </para>
       <para>
        Perform any install/upgrade tasks required at this point.  This
        method is called if the module version in the module.inc does
        not match the version number in the database.  If this method
        completes successfully, it should have set its version number
        in the database appropriately so that it will not be called
        again.  Typically a module will call upon the storage system to
        load any new tables or alter existing ones, upgrade any module
        parameters, and register any new permissions.
       </para>
      </listitem>
      <listitem>
       <para>
        getSiteAdminViews()
       </para>
       <para>
        Using this method you can return a list of views (see the
        Model-View-Controller pattern below) that this module will
        display in the <emphasis>Site Admin</emphasis> section of
        Gallery.
       </para>
       <para>
        The returned views should be in an array of the format:
        <programlisting>
         array('text' => $this->translate('delete item'),
         'params' => array('view' => 'core:ItemAdmin',
         'subView' => 'core:ItemEditPermissions'));
        </programlisting>
        Note that the text value is localized since it will be
        displayed directly to the user.
       </para>
      </listitem>
      <listitem>
       <para>
        getItemAdminViews()
       </para>
       <para>
        Using this method you can return a list of item administration
        views (see the Model-View-Controller pattern below) that this
        module will display for each item.  The module should check
        permissions and item type to determine which views are
        applicable for the authenticated user.  As with
        getSiteAdminViews(), the view title text must be localized.
       </para>
      </listitem>
      <listitem>
       <para>
        getConfigurationView()
       </para>
       <para>
        Get the name of the GalleryView containing the administration
        view specifically for configuring this module.  It may be one
        that is also listed in getSiteAdminViews().  As with
        getSiteAdminViews(), the view title text must be localized.
       </para>
      </listitem>
      <listitem>
       <para>
        getSystemLinks()
       </para>
       <para>
        Return links to system level views.  These are views that are
        relevant throughout the system but are unrelated to any given
        item.  The login, logout and site admin links are examples of
        these types of links.  As with getSiteAdminViews(), the view
        title text must be localized.
       </para>
      </listitem>
      <listitem>
       <para>
        getSystemContent()
       </para>
       <para>
        Return system level content.  This is similar to system links,
        but it's actually HTML content and not a link to a view.  It
        must be localized since it will be displayed directly to the
        user.  This is useful for things like the search module that
        want to embed a search box on every page.
       </para>
      </listitem>
      <listitem>
       <para>
        getItemLinks()
       </para>
       <para>
        Return item specific links.  These are links to item specific
        module views.  For example, the comments module uses this to
        link to the "add comments" view.
       </para>
      </listitem>
      <listitem>
       <para>
        getItemSummaries()
       </para>
       <para>
        Return item specific summaries.  This is localized content
        specific to a given item.  For example, the comments module
        uses this to display the last few comments about an item.
       </para>
      </listitem>
      <listitem>
       <para>
        getItemDetails()
       </para>
       <para>
        Return item specific details.  This is localized content
        specific to a given item.  You can use this to return in-depth
        item content.  In theory it should be more detailed than the
        item summaries.
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect4>
   <sect4>
    <title>
     classes
    </title>
    <para>
     This is the home for any entities, items and helper classes that
     you create.  See the comment and search modules for examples of
     these.  
    </para>
   </sect4>
   <sect4>
    <title>
     PHPUnit Tests
    </title>
    <para>
     You should create your PHPUnit tests inside the tests/phpunit
     directory.  Framework tests should extend GalleryTest, and
     controller tests should extend GalleryControllerTest.  Examine
     those classes (in gallery2/setup/phpunit) to find common
     convenience methods that you can use in your tests.
    </para>
    <para>
     Unit tests should make an effort to avoid messing with existing
     data and to leave the database in a clean state when they're
     done.  It's ok for the tests to screw with the database when they
     fail (what can ya do), but not when they run successfully.  You
     should be able to run tests repeatedly without having to rebuild
     the database, etc.
    </para>
   </sect4>
  </sect3>
  <sect3>
   <title>
    Official Modules
   </title>
   <itemizedlist>
    <listitem>
     <para>
      core
     </para>
     <para>
      As the name implies, this is the home of the core Gallery 2
      functionality.  This is standard module, with the exception that
      it gets loaded up first so that it can provide a framework for
      all the rest of the modules.  It contains all the relevant
      underlying technologies like the platform, storage subsystem,
      implementation factories, toolkits, caching system, entities, maps,
      events, etc.
     </para>
     <para>
      The core module provides the base set of GalleryEntities and
      GalleryMaps that form the framework for all managed data.  Here
      is a
      <ulink url="http://gallery.menalto.com/modules.php?set_albumName=userguide&amp;id=aab&amp;op=modload&amp;name=gallery&amp;file=index&amp;include=view_photo.php">
       UML diagram of all GalleryEntities
      </ulink>
      .  At the moment, this diagram only contains the core entities
      and their members.  It does not include core maps, helper
      classes, entities from other modules or entity methods.
     </para>
    </listitem>
    <listitem>
     <para>
      search
     </para>
     <para>
      This module provides a means of searching all other Gallery
      modules.  It accomplishes this by publishing a search interface
      that all other modules (that wish to be searchable) implement.
      The search module provides views and controllers that allow it
      to perform searches on the other modules via this interface.
     </para>
    </listitem>
    <listitem>
     <para>
      imagemagick
     </para>
     <para>
      This is an ImageMagick implementation of the GalleryToolkit API.
     </para>
    </listitem>
    <listitem>
     <para>
      netpbm
     </para>
     <para>
      This is a NetPBM implementation of the GalleryToolkit API.
     </para>
    </listitem>
    <listitem>
     <para>
      comments
     </para>
     <para>
      This module provides support for adding comments to
      GalleryItems.  It creates its own table in the database for
      storing comments as well as views for adding, editing and
      removing comments.  It implements the search interface so that
      comments are searchable.
     </para>
    </listitem>
   </itemizedlist>
  </sect3>
 </sect2>
 <sect2 id="gallery2.dev-guide.layouts">
  <title>
   Layouts
  </title>
  <para>
   Layouts are working, but are expected to change somewhat in the
   near future so we haven't fully doc'd them yet.
  </para>
 </sect2>
 <sect2 id="gallery2.dev-guide.themes">
  <title>
   Themes
  </title>
  <para>
   Themes are working, but are expected to change somewhat in the
   near future so we haven't fully doc'd them yet.
  </para>
 </sect2>
 <sect2 id="gallery2.dev-guide.patterns">
  <title>
   Patterns
  </title>
  <para>
   Gallery makes use of quite a few design patterns in the code.
   These patterns are design and coding methodologies that make it
   easier to implement and understand large systems.  If you're
   working on the official Gallery codebase, you must understand and
   use them in the code that you write.  If you're developing your own
   module, we strongly recommend that you follow these patterns since
   it'll make it that much easier to integrate your module into the
   official module set (which is a good thing).
  </para>
  <sect3>
   <title>
    Entities
   </title>
   <para>
    An entity in Gallery is an atomic chunk of data that can be loaded
    from and saved to the database and has its own internal behaviour.
    Each entity has its own unique id, creation timestamp,
    modification timestamp, serial number and entity type.  All
    entities are subclasses of GalleryEntity.  You never create an
    instance of GalleryEntity itself; it's an abstract class even
    though PHP doesn't explicitly support abstract classes.  When you
    want a new instance of an entity you should create it using the
    GalleryFactory (described below).
   </para>
   <para>
    There are a variety of different types of entities that server
    different purposes.  In the Gallery object model we take advantage
    of inheritance to create subclasses of entities that contain only
    the data and behaviour that we need.  For example, groups and
    users do not have a parent/child relationship with other entities
    so they directly subclass GalleryEntity.  Everything else in the
    system has a parent/child relationship so we have a new entity
    type called GalleryChildEntity that subclasses GalleryEntity and
    contains a <emphasis>parentId</emphasis> member.  Read the UML
    diagram to see exactly how the various entities are related.
   </para>
   <para>
    Gallery data is arranged in a tree starting with a single
    GalleryAlbumItem as the root.  The root album contains other
    GalleryItems which are either GalleryAlbumItems or
    GalleryDataItems.  GalleryDataItems are the manageable data types
    such as GalleryPhotoItem or GalleryMovieItem instances.  Modules
    can introduce new item types by creating entities that extend
    GalleryDataItem and registering them with the GalleryFactory.
   </para>
   <para>
    GalleryEntities contain contents that have special embedded
    metadata in them.  We use this metadata to describe the entity in
    such a way that our automated tools can automatically generate
    interface classes and SQL table definitions for the entity.  This
    saves a considerable amount of time writing code by hand.  Read
    the "Code Generation" section for more details on how this works.
   </para>
   <para>
    You create a new GalleryEntity by first getting an instance of it
    from the GalleryFactory:
    <programlisting>
     list ($ret, $user) = GalleryFactory::newInstance('GalleryEntity', 'GalleryUser');
     if ($ret->isError()) { 
         return array($ret->wrap(__FILE__, __LINE__), null); 
     }

     if (!isset($user)) {
         return array(GalleryStatus::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__), null);      
     }
    </programlisting>
    Note a couple of things about the above code.  First, we know that
    we want to create a GalleryUser, and that GalleryUser extends
    GalleryEntity.  This allows us to make the specific factory call
    telling it to give us an instance of the GalleryUser class.  Now
    the nice thing is that we don't actually care what GalleryUser we
    get back as long as we get back something that fulfills the
    GalleryUser API.  This is necessary since later on when we embed
    Gallery inside another system we'll change the factory method to
    return (for example) an instance of PostNukeGalleryUser and our
    application logic will still function properly.
   </para>
   <para>
    The other thing to note is that we don't actually know for sure
    that we received back an instance of the class.  We may have asked
    for a class type that is not registered, so not only do we have to
    check for (and handle) an error code, but we have to handle the
    situation where no object was returned.  Now in the case of
    GalleryUser it's pretty unlikely that we won't have an
    implementation handy, but it's still a good pattern to check so
    that we can meet our reliability goal.
   </para>
   <para>
    It's not always going to be the case that we know exactly what
    type of entity we want, especially when we're creating new
    GalleryItem types.  Typically, we want to create a GalleryItem
    based on the mime type of the file the user just uploaded.  This
    is when the factory code really shines, since we can allow modules
    to create their own GalleryDataItem entities and register them
    with the factory so that we can simply do this:
    <programlisting>
     list ($ret, $newItem) = GalleryItemHelper::newItemByMimeType($mimeType); 
     if ($ret->isError()) { 
         return $ret->wrap(__FILE__, __LINE__);
     }
    </programlisting>
    Note that in this example, we're going to get back a GalleryItem
    but we have no idea what the actual implementation is.  In the
    core module, we map some mime types to GalleryPhotoItem, some to
    GalleryMovieItem and the rest to GalleryUnknownItem.  But there
    may be a new module in the system that has created a
    FlashMovieItem type and registered it with the
    <emphasis>application/x-shockwave-flash</emphasis> mime type, and
    we might be getting one of those entities back if the user
    uploaded a flash movie.  We don't know, and we don't care as long
    as the entity returned is a GalleryItem.
   </para>
   <para>
    You must write lock a GalleryEntity before you modify or delete
    it.  However, you do not have to write lock it before creating the
    entity, since nothing else can modify it before you create it.
    However, you should read lock the parent to make sure that it does
    not get modified while you're creating entities inside it.Entity
    creation looks like this (without locking; see the locking section
    for examples with locking also).
    <programlisting>
     // use the factory to get a new instance of GalleryUser, as shown above
     // then call create.
     $ret = $user->create("jdoe");
     if ($ret->isError()) {
         return $ret->wrap(__FILE__, __LINE__);
     }

     $user->setEmail("jdoe@jdoe.com");

     // Now we have a well formed instance of GalleryUser in memory so save
     // it to the database:
     $ret = $user->save();
     if ($ret->isError()) {
         return $ret->wrap(__FILE__, __LINE__);
     }
    </programlisting>
    Modifying or deleting entities requires you to lock and refresh
    the item before you change or delete it.
    <programlisting>
     // Let's assume $user is a loaded GalleryUser entity.  First we lock it:
     list ($ret, $lockId) = $gallery->acquireWriteLock($user->getId());
     if ($ret->isError()) {
         return $ret->wrap(__FILE__, __LINE__);
     }

     // Then we refresh the user in case somebody modified it in the window between
     // when we loaded it and when we acquired the lock
     $ret = $user->refresh();
     if ($ret->isError()) {
         return $ret->wrap(__FILE__, __LINE__);
     }

     // Then modify the item
     $user->setEmail("jdoe@jdoe.com");

     // Now save it:
     $ret = $user->save();
     if ($ret->isError()) {
         return $ret->wrap(__FILE__, __LINE__);
     }

     // And then release our write lock
     list ($ret, $lockId) = $gallery->releaseLocks($lockId);
     if ($ret->isError()) {
         return $ret->wrap(__FILE__, __LINE__);
     }
    </programlisting>
    Deleting is the same as saving, except that you use the delete()
    method on the entity instead of save().  And you can also use the
    <programlisting>$gallery->deleteEntityById()</programlisting>
    convenience method instead since that handles all the locking
    issues and doesn't require you to actually load the entity just so
    that you can delete it.
   </para>
  </sect3>
  <sect3>
   <title>
    Maps
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Helpers
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Templates
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Locking
   </title>
   <para>
    G2 employs a locking methodology called "Pessimistic
    Locking".  What this means is that whenever the application
    layer wants to change an entity that already exists in the
    system, it must lock the entity before it begins editing and
    release the lock when its done.  While this entity is
    locked, no other session can touch the entity.
   </para>
   <para>
    We use two types of locks: read locks and write locks.
    Holding a read lock on an entity means that nobody can edit
    it.  That's useful in the case where you want to make sure
    that an entity (eg, an album) doesn't get moved while you're
    working with it.  The other type of lock is a write lock.
    It allows your session the exclusive ability to edit an
    entity.
   </para>
   <para>
    The general rule is that you acquire a lock as far upstream
    as possible.  When performing complex operations (like
    moving items, etc) only the application logic really knows
    what's going on.  The framework can check to make sure that
    a lock is acquired but in general, each framework call
    doesn't know the context that it's getting called in so it
    shouldn't be responsible for acquiring the lock.
   </para>
   <para>
    For example if we're writing the the move or copy item
    logic, at the app level we want to acquire a read lock on
    the source and destination albums and on all of their
    parents.  This prevents the source/destination containers
    from getting moved around while we're moving items within
    them.  Then we want to write-lock the items we're moving so
    that nobody can fiddle with them while we're moving them.
    Thus we can successfully move or copy the items safe in the
    knowledge that our operation should complete successfully.
   </para>
   <para>
    One of the interesting problems that we address in G2 is
    avoiding data corruption.  If you're using G2 in a
    transactional database, you should never get data corruption
    in the database.  However, we don't have a journalling
    filesystem and it's common for us to do filesystem
    operations at the same time as the database operations.  If
    the database transaction fails, the database changes will be
    rolled back cleanly but we'll be left with corruption in the
    filesystem (eg, an item gets moved to a new location but
    then the database statement fails, it all rolls back but the
    file gets stranded in the new place).  In a perfect world,
    we will check our database operations and trying to undo any
    filesystem changes if it looks like the database operation
    failed.  It's not perfect (and we're not doing it properly
    in a lot of places) but it's possible.
   </para>
   <para>
    Pessimistic locking minimizes the above problem.  We assume
    that there will be concurrency issues and try to lock all
    objects that we're going to touch.  We read lock anything
    that we're not going to change and write lock anything that
    we are going to change.  The downside is that because not
    all databases have row-level locking, the locking strategy
    involves quite a few reads and writes to a lock table so
    locking is somewhat expensive.  
   </para>
   <para>
    Only GalleryEntities are locked.  Data in maps is considered
    to be of a more transient nature and less susceptible to
    concurrency issues.  So in order to minimize the expense,
    we've moved some columns out of the entities and into the map
    classes.  These columns (like view count, etc) are much
    faster because they are not protected by locks, but the
    downside is that it's possible for them to be updated
    inaccurately so they're slightly less reliable.
   </para>
   <para>
    One possible alternative to the above solution is to let the
    framework handle all locking under the covers and not expose
    it at the application logic level.  This would make new
    application logic easier to write, since you wouldn't have
    to worry about locking.  There are a few reasons why this
    won't work:
    <itemizedlist>
     <listitem>
      <para>
       We don't know for sure that we have transactions, and
       we don't want to fail in the middle of an operation
       and corrupt our database and our filesystem, so we
       should try to acquire all write locks up front to
       ensure success before we make any changes.  That can
       only be done in the controller, since no other part of
       the code knows exactly what we need.
      </para>
     </listitem>
     <listitem>
      <para>
       Locking is expensive in environments without good
       row-level locking (eg, MySQL) so it's best to try to
       acquire lots of locks at once instead of doing them as
       we find out that we need them.
      </para>
     </listitem>
     <listitem>
      <para>
       Right after you get the write lock for an entity, you
       must refresh the entity, otherwise you don't know for
       sure that you have the latest version (somebody else
       might have had the write lock, modified the entity and
       released the lock in between the time that you loaded
       the entity and when you successfully acquire the write
       lock).  This can also only be done safely at the top.
      </para>
     </listitem>
    </itemizedlist>
    The framework helps out by not allowing you to save an
    entity unless it is write locked.  So the main issue is
    knowing when to acquire read locks (more on that below).
   </para>
  </sect3>
  <sect3>
   <title>
    Factories
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Model-View-Controller
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Internationalization and Localization
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Storage
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Platform
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Code Generation
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Cross-Module Interfaces
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Event Listeners
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Data Caching
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Gallery Toolkit
   </title>
   <para>&nbsp;
   </para>
  </sect3>
 </sect2>
 <sect2 id="gallery2.dev-guide.support">
  <title>
   Support
  </title>
  <sect3>
   <title>
    Libraries
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Setup
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Docs
   </title>
   <para>&nbsp;
   </para>
  </sect3>
 </sect2>
</sect1>
