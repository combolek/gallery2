<?xml version="1.0" encoding="ISO-8859-1"?>
<sect1 id="gallery.dev-guide">
 <title>Gallery 2.0 Developer's Guide</title> 
 
 <sect2 id="gallery.dev-guide.intro">
  <title>
   Introduction 
  </title>
  <sect3>
   <title>
    Goals
   </title>
   <para>
    Gallery 2.x is designed to be the next generation category killer of
    open source photo presentation software.  With this product, users can
    quickly and easily publish their media (photos, movies, audio clips,
    etc).  It is reliable, scalable, flexible, modular, intuitive,
    localizable, portable and easily customizable.        
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Reliable
     </para>
     <para>
      G2 will be reliable at all times.  It will never lose your data, ever.
     </para>
    </listitem>
    <listitem>
     <para>
      Scalable
     </para>
     <para>
      G2 will scale to managing hundreds of thousands of images
      with little or no degradation in its processing speed.
      Viewing an album will be just as fast if it contains 10
      items or 10000 items.
     </para>
    </listitem>
    <listitem>
     <para>
      Flexible
     </para>
     <para>
      The G2 layout and theme system will allow you to present
      G2 in many different ways to suite your particular needs,
      from family websites to corporate employee databases to
      merchant catalogs.
     </para>
    </listitem>
    <listitem>
     <para>
      Modular
     </para>
     <para>
      The G2 module API provides a mechanism for developers to
      add new functionality quickly and easily.  These new
      modules have all the power of existing ones and will
      integrate seamlessly into the product.
     </para>
    </listitem>
    <listitem>
     <para>
      Localizable
     </para>
     <para>
      G2 will separate out all user-visible content such that it
      can be readily localized into any language.
     </para>
    </listitem>
    <listitem>
     <para>
      Intuitive
     </para>
     <para>
      G2 will be intuitively easy to install and use.  Users who
      browse G2 will have no problem understanding how to
      navigate the product and use it effectively.
     </para>
    </listitem>
    <listitem>
     <para>
      Customizable
     </para>
     <para>
      The styles and layouts used in G2 will be separated from
      the code so that they can be easily modified by the G2
      administrator.
     </para>
    </listitem>
    <listitem>
     <para>
      Portable
     </para>
     <para>
      G2 will work on any PHP platform and support a wide range of data
      processors (eg, image toolkits) and all the popular database
      solutions.
     </para>
    </listitem>
   </itemizedlist>
  </sect3>
  <sect3>
   <title>
    Brief History
   </title>
   <para>
    In the beginning there was Gallery 1.x.  Actually, in the
    beginning Bharat bought a digital camera and thought "wouldn't
    it be nice if I could put these photos somewhere."  But when
    Gallery 1.x came into being, the developers had no idea what
    they were doing.  They didn't know PHP very well, didn't
    understand the importance of separating code from content,
    didn't have a whole lot of database experience, you get the
    idea.  So they started by just writing something that worked,
    and then slowly building upon it.  The end result is Gallery
    1.x which works quite nicely but internally is a bit of a
    mess.
   </para>
   <para>
    When the developers realized that Gallery was going to be a
    useful and successful product, they were faced with a choice:
    fix all the various problems with Gallery 1.x, or start from
    scratch and build Gallery 2.x which does everything the right
    way and doesn't have all the various problems that abound in
    Gallery 1.x.  After much discussion, they decided that only a
    complete rewrite would fix some of the fundamental problems
    with Gallery 1.x and G2 was born.
   </para>
  </sect3>
 </sect2>
 <sect2 id="gallery.dev-guide.concepts">
  <title>
   Concepts
  </title>
  <sect3>
   <title>
    Test Driven Development
   </title>
   <para>
    Writing a application that must run on many different
    platforms, works with multiple databases and is based on
    emerging technologies can be very challenging. Especially when
    the development is distributed and has been in progress over a
    long period of time. As we've worked on Gallery2 we've found
    issues with the design and implementation that make us want to
    rework large parts of the system. However, we fear making
    large changes because even though G2 is modular and well
    written there are still interdependencies between different
    parts of the system and there's the chance that we're breaking
    something critical. After all, how do we have to know that our
    change is going to work on all of our platforms and databases
    without doing a lot of exhaustive and manual testing? This can
    be daunting and it tends to impose a conservative mindset
    where we fear to enact change because we know that we won't be
    able to find out the consequences until its too late. That is
    unacceptable; we must be willing to make large changes or
    we'll get stuck with an inferior design.
   </para>
   <para>
    Enter Test Driven Development.
   </para>
   <para>
    This is a strategy whereby every new bit of functionality
    starts its life as a test. We envision the feature and then
    write a test that will only succeed when the feature is
    complete. Initially when we run the test it fails because we
    haven't written the feature yet. Then we go and write the
    feature until it satisfies the test. If we think of a new
    twist or restrictrion on the feature then we write a new test
    and then keep working on the code until that test passes
    also. Pretty soon we have a very large set of tests, and all
    of our code is getting tested regularly. If we find something
    that doesn't look right, or can be combined with other code we
    can feel free to make as many small or large changes as we
    want, as long as when we check the changes in the tests still
    run. Find a bug? Write a test that fails until the bug is
    fixed. Want to add a feature? Write a test first. Code running
    slow? Refactor and optimize at will as long as the tests still
    run. Want to know if your code is going to work on a different
    platform? Go to that platform and run the tests. Find a bug on
    that platform? Write a test to expose the bug, fix the bug so
    that the test works, check it all in and then go and run the
    tests on the first platform.
   </para>
   <para>
    G2 uses a system called phpunit to do unit testing and at the
    time of this writing has about 150 tests covering almost all
    of the core and part of the core feature set. We started doing
    test driven development after writing the bulk of the code so
    we've been playing catchup to write tests to cover all the
    stuff we've already written. Soon we'll have written tests for
    all existing functionality, and all new functionality will
    stem from tests. If you want to see what the test suite looks
    like, install G2 and browse to
    gallery2/setup/phpunit/index.php
   </para>
   <para>
    Test Driven Development is not our idea. It stems from a
    methodology called Extreme Programming. Bharat learned about
    Extreme Programming while doing development on SourceForge,
    grew enamored of it and decided that while not all principles
    could be applied to an open source project like Gallery, at
    least some of them were of tremendous value. For more
    information about Extreme Programming read these links:
    <itemizedlist>
     <listitem>
      <para>
       <ulink url="http://www.google.com/search?q=extreme+programming">
	<citetitle>
	 Extreme Programming Google Links
	</citetitle>
       </ulink>
      </para>
     </listitem>
     <listitem>
      <para>
       <ulink url="http://junit.sourceforge.net/doc/testinfected/testing.htm">
	<citetitle>
	 Test Infected
	</citetitle>
       </ulink>
      </para>
     </listitem>
     <listitem>
      <para>
       <ulink url="http://www.artima.com/intv/testdriven4.html">
	<citetitle>
	 Test Driven Development
	</citetitle>
       </ulink>
      </para>
     </listitem>
     <listitem>
      <para>
       <ulink url="http://www.xprogramming.com/xpmag/whatisxp.htm">
	<citetitle>
	 What is Extreme Programming?
	</citetitle>
       </ulink>
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect3>
  <sect3>
   <title>
    Embedding Gallery in Other Applications
   </title>
   <para>
    Gallery is designed very specifically to manage your
    multimedia online.  It's not a content management system or a
    blog or a website editor.  However, there's no reason why
    Gallery can't be the multimedia management portion of a much
    larger system which does much more context content management
    or blogging, etc.  Many such systems focus on their core
    competency and provide a very weak multimedia management
    system.  Gallery is designed to work within those larger
    systems and provide the functionality that they lack.
   </para>
   <para>
    In order to make this process of embedding easier, Gallery is
    very careful about not polluting global namespaces.  Core
    classes, constants, database tables, etc are prefixed with
    different forms of "gallery" to identify them as separate from
    the outer program.
   </para>
   <para>
    How we actually go about embedding Gallery into another
    program depends heavily on which program we are going to work
    with.  For PHP CMS systems like PostNuke/PHP-Nuke, we will
    need to create a new entry point into G2 that replaces
    main.php. This new entry point will be PostNuke/PHP-Nuke
    specific and will give us a way to interoperate between the
    two.  Then we need to extend the database storage layer so
    that it understands that the user/group information is now
    stored in a different table/column arrangement so that our
    queries continue to function. Then we need disable certain
    functionality (like user management) and provide some new
    templates for the administration console so that we can tie
    the G2 site admin interface into the CMS' admin system.
   </para>
   <para>
    I'm envisioning shipping a snap-on pack for each CMS that
    converts your G2 install into one that works for the specific
    CMS. It'll work by adding new files/modules to the G2 install
    (but not replacing existing files).  This is in the
    speculative stage so no substantive work has been done on it
    yet.
   </para>
  </sect3>
  <sect3>
   <title>
    Redirect-On-Post
   </title>
   <para>
    One aggravating thing about may dynamic websites is the
    situation where you want to reload a page, but the page was
    created by a form submission and reloading the page will
    submit the form again which may do something you did not
    intend.  To avoid this problem, G2 will always redirect you to
    a new page after you successfully complete an operation.  If
    you do a form post and it *doesn't* do anything (ie, it gives
    you an error) it won't redirect since it's safe to reload that
    page again if you choose.  Of course, reloading that page will
    just give you the same error, but at least it won't cause any
    damage.
   </para>
  </sect3>
  <sect3>
   <title>
    Coding standards
   </title>
   <para>
    Clean code is important, especially when many developers are
    collaborating.  Read and obey the style guide:
    <ulink url="http://gallery.menalto.com/modules.php?op=modload&amp;name=GalleryDocs&amp;file=index&amp;req=viewarticle&amp;artid=19">
     http://gallery.menalto.com/modules.php?op=modload&amp;name=GalleryDocs&amp;file=index&amp;req=viewarticle&amp;artid=19
    </ulink>
   </para>
  </sect3>
  <sect3>
   <title>
    Check all return codes
   </title>
   <para>
    Reliability is one of Gallery's fundamental goals.  The path
    to reliability is to religiously check every single return
    code and make sure that when something goes wrong we handle it
    in the most appropriate way.
   </para>
   <para>
    Sadly, PHP lacks exception handling which means that we have
    to comeup with our own way to check return values.  G2 has its
    own system for returning status values such that errors bubble
    up to the top and can be handled at every step of the way.  We
    build up a stack trace while handling these errors and this
    stack trace can be used to diagnose problems when they occur.
   </para>
   <para>
    Any method that can fail should return an instance of a
    GalleryStatus object.  In the case of a successful result, it
    should return:
    <programlisting>
     return GalleryStatus::success();
    </programlisting>
    Upon failure, it should return the appropriate error code along
    with the relevant file name and line number like this:
    <programlisting>
     return GalleryStatus::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__);
    </programlisting>
    The complete list of error codes can be found in the
    modules/core/GalleryStatus class.  The code that calls this method
    should check this error code and handle it properly:
    <programlisting>
     $ret = methodThatReturnsStatus();
     if ($ret->isError()) {
         return $ret->wrap(__FILE__, __LINE__);
     }
    </programlisting>
    Note that we tag on the file and line numbers when we return the
    status code.  This is how we build up the stack trace.  We follow
    the convention that all status codes are called
    <emphasis>$ret</emphasis>.  This is a good idea in case we wish to
    refactor this code later on; it'll make those lines easier to
    find.  Note also that if your method returns other values, it
    should return an array so that the first element can be a status
    code.
   </para>
  </sect3>
 </sect2>
 <sect2 id="gallery.dev-guide.modules">
  <title>
   Modules
  </title>
  <para>
   Modules are where all of the Gallery functionality lives.  Even
   the core Gallery framework is a module.  Modules can be added and
   removed from the Gallery framework and each module can add
   virtually unlimited functionality.  Modules can use existing
   database tables, they can use APIs from other modules, they can
   introduce new item types into the gallery.  In short, they are
   where all new functionality will go.
  </para>
  <sect3 id="gallery.dev-guide.modules.components">
   <title>
    Module Components
    </title>
   <para>
    All modules live within the modules/ directory inside the Gallery
    directory.  Each module must contain a file called "module.inc" at
    the top level which contains a PHP class that extends
    GalleryModule.  The GalleryModule class provides a very simple
    module implementation designed to be a framework that you can
    build on.  You must override some of the GalleryModule methods in
    your own module implementation to give it the behaviour that you
    want.  
    <itemizedlist>
     <listitem>
      <para>
       init()
      </para>
      <para>
       Do any initialization required for this module to run.  The
       init method is called on every active module on every request.
       You should not do anything heavy in this method if you can
       avoid it.  Typically you would register any GalleryFactory
       implementations (see below) at this time.  See the
       <emphasis>comment</emphasis> module for an example.
      </para>
     </listitem>
     <listitem>
      <para>
       install()
      </para>
      <para>
       Perform any install/upgrade tasks required at this point.  This
       method is called if the module version in the module.inc does
       not match the version number in the database.  If this method
       completes successfully, it should have set its version number
       in the database appropriately so that it will not be called
       again.  Typically a module will call upon the storage system to
       load any new tables or alter existing ones, upgrade any module
       parameters, and register any new permissions.
      </para>
     </listitem>
     <listitem>
      <para>
       getSiteAdminViews()
      </para>
      <para>
       Using this method you can return a list of views (see the
       Model-View-Controller pattern below) that this module will
       display in the <emphasis>Site Admin</emphasis> section of
       Gallery.
      </para>
      <para>
       The returned views should be in an array of the format:
       <programlisting>
	array('text' => $this->translate('delete item'),
              'params' => array('view' => 'core:ItemAdmin',
	                        'subView' => 'core:ItemEditPermissions'));
       </programlisting>
       Note that the text value is localized since it will be
       displayed directly to the user.
      </para>
     </listitem>
     <listitem>
      <para>
       getItemAdminViews()
      </para>
      <para>
       Using this method you can return a list of item administration
       views (see the Model-View-Controller pattern below) that this
       module will display for each item.  The module should check
       permissions and item type to determine which views are
       applicable for the authenticated user.  As with
       getSiteAdminViews(), the view title text must be localized.
      </para>
     </listitem>
     <listitem>
      <para>
       getConfigurationView()
      </para>
      <para>
       Get the name of the GalleryView containing the administration
       view specifically for configuring this module.  It may be one
       that is also listed in getSiteAdminViews().  As with
       getSiteAdminViews(), the view title text must be localized.
      </para>
     </listitem>
     <listitem>
      <para>
       getSystemLinks()
      </para>
      <para>
       Return links to system level views.  These are views that are
       relevant throughout the system but are unrelated to any given
       item.  The login, logout and site admin links are examples of
       these types of links.  As with getSiteAdminViews(), the view
       title text must be localized.
      </para>
     </listitem>
     <listitem>
      <para>
       getSystemContent()
      </para>
      <para>
       Return system level content.  This is similar to system links,
       but it's actually HTML content and not a link to a view.  It
       must be localized since it will be displayed directly to the
       user.  This is useful for things like the search module that
       want to embed a search box on every page.
      </para>
     </listitem>
     <listitem>
      <para>
       getItemLinks()
      </para>
      <para>
       Return item specific links.  These are links to item specific
       module views.  For example, the comments module uses this to
       link to the "add comments" view.
      </para>
     </listitem>
     <listitem>
      <para>
       getItemSummaries()
      </para>
      <para>
       Return item specific summaries.  This is localized content
       specific to a given item.  For example, the comments module
       uses this to display the last few comments about an item.
      </para>
     </listitem>
     <listitem>
      <para>
       getItemDetails()
      </para>
      <para>
       Return item specific details.  This is localized content
       specific to a given item.  You can use this to return in-depth
       item content.  In theory it should be more detailed than the
       item summaries.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect3>
  <sect3>
   <title>
    core
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    search
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    imagemagick
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    netpbm
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    comments
   </title>
   <para>&nbsp;
   </para>
  </sect3>
 </sect2>
 <sect2 id="gallery.dev-guide.layouts">
  <title>
   Layouts
  </title>
  <para>&nbsp;
  </para>
  <sect3>
   <title>
    classic
   </title>
   <para>&nbsp;
   </para>
  </sect3>
 </sect2>
 <sect2 id="gallery.dev-guide.themes">
  <title>
   Themes
  </title>
  <para>&nbsp;
  </para>
  <sect3>
   <title>
    classic
   </title>
   <para>&nbsp;
   </para>
  </sect3>
 </sect2>
 <sect2 id="gallery.dev-guide.patterns">
  <title>
   Patterns
  </title>
  <para>&nbsp;
  </para>
  <sect3>
   <title>
    Entities
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Maps
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Helpers
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Templates
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Locking
   </title>
   <para>
    G2 employs a locking methodology called "Pessimistic
    Locking".  What this means is that whenever the application
    layer wants to change an entity that already exists in the
    system, it must lock the entity before it begins editing and
    release the lock when its done.  While this entity is
    locked, no other session can touch the entity.
   </para>
   <para>
    We use two types of locks: read locks and write locks.
    Holding a read lock on an entity means that nobody can edit
    it.  That's useful in the case where you want to make sure
    that an entity (eg, an album) doesn't get moved while you're
    working with it.  The other type of lock is a write lock.
    It allows your session the exclusive ability to edit an
    entity.
   </para>
   <para>
    The general rule is that you acquire a lock as far upstream
    as possible.  When performing complex operations (like
    moving items, etc) only the application logic really knows
    what's going on.  The framework can check to make sure that
    a lock is acquired but in general, each framework call
    doesn't know the context that it's getting called in so it
    shouldn't be responsible for acquiring the lock.
   </para>
   <para>
    For example if we're writing the the move or copy item
    logic, at the app level we want to acquire a read lock on
    the source and destination albums and on all of their
    parents.  This prevents the source/destination containers
    from getting moved around while we're moving items within
    them.  Then we want to write-lock the items we're moving so
    that nobody can fiddle with them while we're moving them.
    Thus we can successfully move or copy the items safe in the
    knowledge that our operation should complete successfully.
   </para>
   <para>
    One of the interesting problems that we address in G2 is
    avoiding data corruption.  If you're using G2 in a
    transactional database, you should never get data corruption
    in the database.  However, we don't have a journalling
    filesystem and it's common for us to do filesystem
    operations at the same time as the database operations.  If
    the database transaction fails, the database changes will be
    rolled back cleanly but we'll be left with corruption in the
    filesystem (eg, an item gets moved to a new location but
    then the database statement fails, it all rolls back but the
    file gets stranded in the new place).  In a perfect world,
    we will check our database operations and trying to undo any
    filesystem changes if it looks like the database operation
    failed.  It's not perfect (and we're not doing it properly
    in a lot of places) but it's possible.
   </para>
   <para>
    Pessimistic locking minimizes the above problem.  We assume
    that there will be concurrency issues and try to lock all
    objects that we're going to touch.  We read lock anything
    that we're not going to change and write lock anything that
    we are going to change.  The downside is that because not
    all databases have row-level locking, the locking strategy
    involves quite a few reads and writes to a lock table so
    locking is somewhat expensive.  
   </para>
   <para>
    Only GalleryEntities are locked.  Data in maps is considered
    to be of a more transient nature and less susceptible to
    concurrency issues.  So in order to minimize the expense,
    we've moved some columns out of the entities and into the map
    classes.  These columns (like view count, etc) are much
    faster because they are not protected by locks, but the
    downside is that it's possible for them to be updated
    inaccurately so they're slightly less reliable.
   </para>
   <para>
    One possible alternative to the above solution is to let the
    framework handle all locking under the covers and not expose
    it at the application logic level.  This would make new
    application logic easier to write, since you wouldn't have
    to worry about locking.  There are a few reasons why this
    won't work:
    <itemizedlist>
     <listitem>
      <para>
       We don't know for sure that we have transactions, and
       we don't want to fail in the middle of an operation
       and corrupt our database and our filesystem, so we
       should try to acquire all write locks up front to
       ensure success before we make any changes.  That can
       only be done in the controller, since no other part of
       the code knows exactly what we need.
      </para>
     </listitem>
     <listitem>
      <para>
       Locking is expensive in environments without good
       row-level locking (eg, MySQL) so it's best to try to
       acquire lots of locks at once instead of doing them as
       we find out that we need them.
      </para>
     </listitem>
     <listitem>
      <para>
       Right after you get the write lock for an entity, you
       must refresh the entity, otherwise you don't know for
       sure that you have the latest version (somebody else
       might have had the write lock, modified the entity and
       released the lock in between the time that you loaded
       the entity and when you successfully acquire the write
       lock).  This can also only be done safely at the top.
      </para>
     </listitem>
    </itemizedlist>
    The framework helps out by not allowing you to save an
    entity unless it is write locked.  So the main issue is
    knowing when to acquire read locks (more on that below).
   </para>
  </sect3>
  <sect3>
   <title>
    Factories
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Model-View-Controller
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Internationalization and Localization
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Storage
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Platform
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Generated Code
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Cross-Module Interfaces
   </title>
   <para>&nbsp;
   </para>
  </sect3>
 </sect2>
 <sect2 id="gallery.dev-guide.support">
  <title>
   Support
  </title>
  <sect3>
   <title>
    Libraries
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Setup
   </title>
   <para>&nbsp;
   </para>
  </sect3>
  <sect3>
   <title>
    Docs
   </title>
   <para>&nbsp;
   </para>
  </sect3>
 </sect2>
</sect1>
