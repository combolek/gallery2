Gallery v2.0 Class API
----------------------
$Id$

This is a draft of the class API for Gallery v2.0.  It contains a
sketch of the class hierarchy for the classes that contain the image
metadata.  In writing this API, I've tried to maintain all the
existing functionality that's available in v1.0 while leaving plenty
of room to expand and cover the features that are yet to come in v2.0.

The following functionality is not (yet) implemented in v2.0.

- fitToWindow
	This is gone entirely.  We should be able to implement this
	using the new layout code.

- mirroring
	I've left this out for now because it's heavily dependant on
	the way that we implement the image firewalling code.  I
	believe that this will be possible to add later, once we
	settle on how we do the image firewall.

- the canDeleteFrom permission -- anybody you trust to delete from an
  album you might as well give full write permission

Things that need to be added to this API:
-----------------------------------------
- How will we handle image rotation?  In v1.x we did it by modifying
  the original file. This has nasty side effects, such as losing the
  EXIF data, potentially corrupting the file, changing the quality due
  to lossiness, etc.  If we do it via derivatives we'd never touch the
  original (avoiding all those complications).  It'd be a bit weird
  because we'd actually have two sources for an image.  The "original"
  source and the "preferred" source which is a rotated derivative from
  the original.  We'd have to make it such that all derivatives from
  this item use the preferred source otherwise the thumbnails/resizes
  would come from the un-rotated image.

- Sorting!

- How do we create the RootAlbum?  There's nothing in the API for
  this, yet.

- Support for some kind of LinkItem (ie, a shared item?)

- Support for user groups

Things that need to be documented more thoroughly in general:
-------------------------------------------------------------
- How permissions work.  Thumbnail sketch: you ask an item if a
  specific user has PERMISSION_CAN_BLAH or PERMISSION_CANNOT_BLAH.
  That item recursively asks it's ancestors for an answer.  We're
  looking for the first parent that has an answer that matches (ie, if
  you're checking the "view" permission you're looking for the
  user to be on the CAN_VIEW or CANNOT_VIEW list, and failing that
  you're looking for Everybody, Nobody or RegisteredUser to be on one
  of those lists).  If no determination can be made, the default is
  CANNOT.

- status codes.  This is mostly in place.  Any time you attempt an
  operation that will actually commit data to the persistent store, you
  can either get a value of SUCCESS, or you can get FAILURE and a
  failure code.  So, if you try to modify a deleted object, you'd get
  a return code of FAILURE & F_DELETED.

  SUCCESS = 0x00000000
  ERROR   = 0x00000001

  If you get a FAILURE, one of the following bit fields can be set:

  E_IN_USE    = 0x00000010	
	- Couldn't acquire a lock to change the object

  E_DELETED   = 0x00000100
	- The object no longer exists

  E_COLLISION = 0x00001000
	- Another change was made at the same time, causing this
	  one to be invalid.

  A typical operation would look like this:

	$status = $item->save();
	if ($status == SUCCESS) {
		// Yay
	} else if ($status & (F_IN_USE | F_COLLISION)) {
		// Prompt the user to retry
	} else if ($status & F_DELETED) {
		// The item was deleted out from under us.
	}

- Creating a new persistence backend (ie, "Filesystem", "MySQL")
  This is not finalized yet.  But I'm thinking that all you need to do is
  to implement a GalleryStorage and GalleryUserDatabase for your
  backend.  The config wizard will instruct the init code to create
  the appropriate GalleryStorage object and store it in the Gallery
  instance.

================================================================================
Classes
================================================================================

/**
 * Global storage container and utility class for Gallery
 *
 * This is a container for global information required for gallery
 * operation, such as configuration, session, user, etc.  It also
 * serves as the GalleryItem manager.  All requests for GalleryItems
 * should go through this class so that they can be cached and shared.
 *
 * @version $Id$
 * @module Gallery
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class Gallery {

	/*
	 * ****************************************
	 *                 Members
	 * ****************************************
	 */

	/**
	 * The id of the root AlbumItem in the Gallery
	 *
	 * @var	string
	 */
	var $_rootAlbumItemId;

	/**
	 * Storage for all configuration variables, set in config.php.
	 * The values contained here can't be modified.  Well, they
	 * can be modified but they can't be saved so it's not a good
	 * idea.  
	 *
	 * @var	object	GalleryMap	$_config;
	 */
	var $_config;

	/**
	 * An instance of the user database class
	 *
	 * @var	object	UserDatabase	$_userDatabase;
	 */
	var $_userDatabase;

	/**
	 * The current GalleryImageToolkit
	 *
	 * @var object	GalleryImageToolkit	$_imageToolkit;
	 */
	var $_imageToolkit;

	/**
	 * Storage for all session variables.  Contains an instance
	 * of the GalleryMap class.
	 *
	 * @var	object	GalleryMap	 $_session;
	 */
	var $_session;

	/**
	 * The backend persistent store for the Gallery class
	 *
	 * @access private
	 * @var	object	GalleryStorage	 $_storage;
	 */
	var $_storage;

	/**
	 * The active locking mechanism
	 *
	 * @access private
	 * @var	object	GalleryLock	$_lock;
	 */
	var $_lock;

	/*
	 * ****************************************
	 *                 Methods
	 * ****************************************
	 */

	/**
	 * Return the id of the GalleryItem associated with the path provided
	 *
	 * Return the id associated with the given path. Example path: 
	 * "/birthdays/fred" .. this is the "fred" item in the "birthdays" 
	 * item.  It doesn't really matter what types of items these are, as 
	 * long as the path is legitimate.
	 *
	 * @access public
	 * @param string the path to a GalleryItem
	 * @return Id
	 */
	function getIdByPath($path) {
		return $this->_storage->getIdByPath($path);
	}

	/**
	 * Get the GalleryItem for the id provided
	 *
	 * Return the GalleryItem associated with this id.  Note  
	 * that this returns the unique object itself, not a copy.
	 * This means that you can change/save it.
	 *
	 * @access public
	 * @param string the id of the item
	 * @return GalleryItem the item	
	 */
	function &getItemById($id) {
		return $this->_storage->getItemById($path);
	}

	/**
	 * Get the DataContainer for the id provided
	 *
	 * Return the DataContainer associated with this id.  Note  
	 * that this returns the unique object itself, not a copy.
	 * This means that you can change/save it.
	 *
	 * @access public
	 * @param string the id of the item
	 * @return GalleryItem the item	
	 */
	function &getDataContainerById($id) {
		return $this->_storage->getDataContainerById($path);
	}

	/**
	 * Search this item to see if it contains the search string.
	 *
	 * If this item has sub-items, search them also.
	 *
	 * @access public
	 * @param string the search criteria
	 * @return array an array of GalleryItem(s)
	 */
	function search($criteria) {
	}

	/**
	 * Return the id of the root GalleryItem
	 *
	 * The root GalleryItem should be an AlbumItem
	 *
	 * @return string the id of the root album
	 * @access public
	 */
	function getRootAlbumItemId() {
	}

	/**
	 * Set the id of the root GalleryItem
	 *
	 * The root GalleryItem should be an AlbumItem.
	 *
	 * @param string the id of the GalleryItem
	 * @access public
	 */
	function setRootAlbumItemId($id) {
	}

	/**
	 * Get the Id of the active user
	 *
	 * The active user is the user who is logged on in this 
	 * session or the EverybodyUser, if nobody is logged on.
	 * 
	 * @return string the id of the current User.
	 * @access public
	 */
	function getActiveUserId() {
	}

	/**
	 * Get the user database 
	 *
	 * Return a reference to the instance of the active
	 * GalleryUserDatabase class.
	 * 
	 * @return GalleryUserDatabase the active user database
	 * @access public
	 */
	function &getUserDatabase() {
	}

	/**
	 * Get the image toolkit
	 *
	 * Return a reference to the instance of the active
	 * GalleryImageToolkit class.
	 * 
	 * @return GalleryImageToolkit the active image toolkit
	 * @access public
	 */
	function &getImageToolkit() {
	}

	/**
	 * Get a copy of the Gallery configuration settings
	 *
	 * Return a copy of the GalleryMap config instance.  Do not
	 * change the copy, as the changes will be lost.  The value of
	 * this config object is generated in config.php
	 * 
	 * @return GalleryMap the Gallery config map
	 * @access public
	 */
	function getConfig() {
	}

	/**
	 * Get the Gallery session object.
	 *
	 * Return a reference to the unique Gallery session object
	 * (implemented as an instance of the GalleryMap class).  Any
	 * changes made to this object will be saved in the session.
	 * 
	 * @return GalleryMap the Gallery session map
	 * @access public
	 */
	function &getSession() {
	}

	/**
	 * Lock the given GalleryNucleus instances.
	 *
	 * Use the active locking mechanism to lock the given GalleryNucleus instances.
	 * 
	 * @param array the GalleryNucleus' to be locked 
	 * @param array how long to wait for the lock before giving up
	 * @return boolean true if the lock was acquired
	 * @access public
	 */
	function lock($array, $timeout) {
		// If we have a lock already, complain and return false
		// If we don't have a lock, get one, register it with the end-of-session handler
		// 	so that it goes away

		// If we acquire the lock, refresh all the objects
		//
		// for ($i = 0; $i < length($array); $i++) {
		//	$array[$i]->refresh();
		// }
	}

	/**
	 * Release the lock
	 *
	 * @access public
	 */
	function unlock() {
	}
}

/**
 * Interface to the locking mechanism
 *
 * This object provides the hooks for locking GalleryNucleus objects
 *
 * @version $Id$
 * @module GalleryLock
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 * @abstract
 */
class GalleryLock {

	/**
	 * Lock a set of objects
	 * 
	 * Lock a set of objects such that:
	 * o There will never be deadlocks
	 * o There will never be locks left hanging
	 *
	 * @access public
	 * @abstract
	 * @param array an array of GalleryNucleus objects
	 * @param int how long we should wait to acquire locks
	 * @return GalleryLock an instance of GalleryLock that holds the locks
	 */
	function lock($objects, $timeout=0) {
		// Be sure to register the unlock() method for when the script ends
	}

	/**
	 * Release all locks
	 * 
	 * Release whatever locks this instance is holding
	 *
	 * @access public
	 * @abstract
	 */
	function unlock() {
	}
}

Implementations
---------------
	GalleryLock/FlockBasedLock.class
	GalleryLock/FileBasedLock.class

/**
 * Interface to the storage mechanism
 *
 * This object provides the hooks for saving and restoring objects in the persistent store.
 *
 * @version $Id$
 * @module GalleryStorage
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 * @abstract
 */
class GalleryStorage {

	/**
	 * Return the id of the GalleryItem associated with the path provided
	 *
	 * Return the id associated with the given path. Example path: 
	 * "/birthdays/fred" .. this is the "fred" item in the "birthdays" 
	 * item.  It doesn't really matter what types of items these are, as 
	 * long as the path is legitimate.
	 *
	 * This method must be implemented by subclasses of Gallery.
	 *
	 * @access public
	 * @abstract
	 * @param string the path to a GalleryItem
	 * @return Id
	 */
	function getIdByPath($path) {
	}

	/**
	 * Get the GalleryItem for the id provided
	 *
	 * Return the GalleryItem associated with this id.  Note  
	 * that this returns the unique object itself, not a copy.
	 * This means that you can change/save it.
	 *
	 * This method must be implemented by subclasses of Gallery
	 *
	 * @access public
	 * @abstract
	 * @param string the id of the item
	 * @return GalleryItem the item	
	 */
	function &getItemById($id) {
	}

	/**
	 * Get the DataContainer for the id provided
	 *
	 * Return the DataContainer associated with this id.  Note  
	 * that this returns the unique object itself, not a copy.
	 * This means that you can change/save it.
	 *
	 * @access public
	 * @param string the id of the item
	 * @return GalleryItem the item	
	 */
	function &getDataContainerById($id) {
	}

	/**
	 * Load a new GalleryNucleus from storage
	 *
	 * Load a new GalleryNucleus from storage
	 *
	 * @access public
	 * @param string the id of the stored GalleryNucleus
	 * @param GalleryNucleus a hint of the type of GalleryNucleus we're loading
	 * @return GalleryNucleus a GalleryNucleus or null if the id is bogus.
	 */
	function load($id, &$nucleus="") {
	}

	/**
	 * Save the changes to the GalleryNucleus
	 *
	 * Save the changes to the GalleryNucleus.  
	 *
	 * @access public
	 * @param GalleryNucleus the GalleryNucleus to save
	 * @return int a status code
	 */
	function save($nucleus) {
	}

	/**
	 * Delete the GalleryNucleus
	 *
	 * Delete the GalleryNucleus.
	 *
	 * @access public
	 * @param GalleryNucleus the GalleryNucleus to delete
	 * @return int a status code
	 */
	function delete($nucleus) {
	}
}

/**
 * A factory for creating GalleryItems
 *
 * This class is used to create new GalleryItems from scratch.  New
 * items are created in a temporary storage location and can then be
 * moved under an existing GalleryItem.
 *
 * @version $Id$
 * @module GalleryMap
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class GalleryItemFactory {
	
	/**
	 * Create a new AlbumItem
	 *
	 * Subclasses must implement this function.
	 * 
	 * @access public
	 * @abstract
	 * @return AlbumItem the new AlbumItem
	 */
	function newAlbumItem() {
	}

	/**
	 * Create the appropriate GalleryItem for the file tag provided.
	 *
	 * Subclasses must implement this function.
	 * 
	 * @access public
	 * @abstract
	 * @param string the file location
	 * @param string the file name (eg, "foo.jpg", "foo.Jpg", "FOO.JPG")
	 * @return GalleryItem the new GalleryItem
	 */
	function createItem($source, $name) {
	}
}

/**
 * Utility storage container
 *
 * This class is a map implementation.  It is a utility class that
 * we'll use for the various data containers that we need in the
 * system.
 *
 * @version $Id$
 * @module GalleryMap
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class GalleryMap {

	/*
	 * ****************************************
	 *                 Members
	 * ****************************************
	 */

	/**
	 * Private storage for internal map data.
	 */
	var $_data;
	
	/*
	 * ****************************************
	 *                 Methods
	 * ****************************************
	 */

	/**
	 * Retrieve data from the map
	 *
	 * Return a reference to the value associated with the given
	 * key for the feature specified.  eg: getValue("core.userId").  
	 * It's important that we return a reference so that if the
	 * value contained is a complex object we can modify it in
	 * place.  For example, if we're modifying the viewed stats
	 * we'd say:
	 *
	 *       $arr =& $map->getValue("stats.viewedItem");
	 *       $arr["album01"]++;                             
	 *
	 * @param mixed the map key
	 * @return mixed the map value
	 * @access public
	 */
	function &getValue($key) {
	}

	/**
	 * Store data in the map
	 * 
	 * Replace the value associated with the given key for
	 * the feature specified.  eg:                        
	 *       setValue("core.galleryVersion", "2.0-cvs")   
	 *
	 * @param mixed the map key
	 * @param mixed the new map value
	 * @access public
	 */
	function setValue($key, $value) {
	}
}


GallerySession (instance of GalleryMap)
---------------------------------------------
	This class is a container for session specific data.
	The naming convention for data that is stored in this
	container is as follows:

		feature.keyName1
		feature.keyName2

	Here are the currently known keys:

	Core keys:
		- core.userId
		- core.galleryVersion

	Feature keys:
		- stats.viewedItem


GalleryConfig (instance of GalleryMap)
--------------------------------------------
	This is a container for all configuration information
	necessary for Gallery to function.  The config wizard will
	create a file which builds an instance of a GalleryMap,
	containing a set of keys describing how Gallery is configured.

	Here are the currently known keys:

	Core keys:	
		- core.config.version
		- core.config.tmpDir
		- core.config.albumDir
		- core.config.galleryUrl (used to be $photoAlbumURL)
		- core.config.albumUrl (used to be $albumDirURL)
		- core.config.debug (boolean)
		- core.config.expectedExecStatus
		- core.config.sessionVar
		- core.config.imageToolKit ("imagetoolkit.netpbm", etc)
			This one specifies which image toolkit we're using

		- core.config.persistence.metadata ("filesystem", "rdb", etc.)
			This one specifies which persistent storage system
			we're using.

		- core.config.persistence.users ("filesystem", "rdb", etc.)
			This one specifies which persistent storage system
			we're using.

		- core.defaults.movieThumbnailPath
		- core.defaults.bordercolor
		- core.defaults.border
		- core.defaults.font
		- core.defaults.cols
		- core.defaults.rows
		- core.defaults.thumbSize
		- core.defaults.resizeSize
		- core.defaults.useFullOnly
		- core.defaults.returnto
		- core.defaults.showOwners
		- core.defaults.albumsPerPage
		- core.defaults.showSearchEngine
		- core.defaults.useOriginalFileNames
		- core.defaults.layout
		
		- core.features
			This is an array of enabled features eg:
			("printing", "zip", "rewrite")


	This is the list of feature keys.  All of these features are
	optional, although there will be interdependencies.  For
	example, you'll need to specify at least one valid
	imagetoolkit or Gallery won't work.  As we add more features
	we'll need to make sure that there are no name clashes at the
	top level.

	Feature keys:
		- printing.shutterfly.enabled (boolean)
		
		- zip.zipinfo.path
		- zip.unzip.path

		- stats.displayClicks

		- comments.allowPublic

		- imagetoolkit.netpbm.pnmDir
		- imagetoolkit.netpbm.pnmtojpeg.path
		- imagetoolkit.netpbm.exif.mode
		 	choices ("jhead", "netpbm", "none")
		- imagetoolkit.netpbm.jhead.path

		- mirror.sites
			array of mirror sites

		- filesystem.albumDir
			This is the location of the image metadata.
			It doesn't necessarily need to be the same as
			core.config.albumDir (although it is in v1.0).
			Only relevant if "core.config.persistence.metadata" 
			is set to "filesystem"

		- filesystem.userDir
			This is the location of the user database.  
			Only relevant if "core.config.persistence.users" 
			is set to "filesystem"

/**
 * The central seed that all Gallery objects are formed around
 *
 * This object performs all of the basic functions required in all
 * Gallery objects.
 *
 * @version $Id$
 * @module GalleryNucleus
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class GalleryNucleus {

	/**
	 * The id of this item
	 */
	var $_id;

	/**
	 * Data version of this GalleryNucleus
	 *
	 * @var float $dataVersion
	 */
	var $_dataVersion;

	/**
	 * The parent of this GalleryNucleus
	 * @var GalleryNucleus
	 */
	var $_parent;

	/**
	 * The path component of this item (eg. "image1").  This
	 * value, when combined with the paths of all the parent
	 * objects (say, "rootAlbum", "album01") will form the
	 * complete path to the item ("rootAlbum/album01/image1").
	 */
	var $_path;

	/**
	 * This is an internal variable that tracks whether or not
	 * we've changed anything in this object that requires that we
	 * update the persistent store.
	 *
	 * @access private
	 */
	var $_needToBeSaved;

	/*
	 * ****************************************
	 *                 Methods
	 * ****************************************
	 */

	/**
	 * Constructor
	 *
	 * If an id is provided, load that object from storage and
	 * become that object.  Else, initialize all variables to their
	 * default values.
	 */
	function GalleryNucleus($id="") {
		global $gallery;
		$storage = $gallery->getStorage();

		if (!empty($id)) {
			$this = $storage->load($id, $this);
		} else {
			// Initialize myself
		}
	}

	/**
	 * Subclasses of GalleryNucleus can use this method to
	 * indicate that their data structure has changed such that we
	 * are required to update the persistent store.
	 * 
	 * @access protected
	 */
	function setNeedToBeSaved() {
	}
	 

	/**
	 * Get the id of this GalleryNucleus
	 *
	 * Get the id of this GalleryNucleus
	 * 
	 * @return string the id of this GalleryNucleus
	 * @access public
	 */
	function getId() {
	}

	/**
	 * Get the version of this GalleryNucleus
	 *
	 * Return the version of this GalleryNucleus' data.
	 * 
	 * @return float the data version of this GalleryNucleus
	 * @access public
	 */
	function getDataVersion() {
	}

	/**
	 * Check the data version and upgrade if necessary
	 *
	 * Check the data version of this GalleryNucleus and instruct it
	 * to upgrade itself, if necessary.
	 * 
	 * @param mixed the new map value
	 * @return bool true if the item was upgraded
	 * @access public
	 */
	function checkDataVersionAndUpgrade() {
	}

	/**
	 * Return the GalleryNucleus that owns this one.
	 *
	 * Return the GalleryNucleus that owns this one.
	 *
	 * @access public
	 * @return GalleryNucleus the parent
	 */
	function getParent() {
	}

	/**
	 * Return the path component of this item
	 *
	 * Return the path component of this item
	 *
	 * @access public
	 * @return string the path component
	 */
	function getPath() {
	}

	/**
	 * Return the full path of this item
	 *
	 * Return the full path of this item
	 *
	 * @access public
	 * @return string the full path
	 */
	function getFullPath() {
	}

	/**
	 * Set the path component of this item
	 *
	 * Set the path component of this item
	 *
	 * @access public
	 * @param string the path component
	 * @return boolean false if the path already exists, true otherwise
	 */
	function setPath($path) {
	}

	/**
	 * Save the changes to this GalleryNucleus
	 *
	 * Save the changes to this GalleryNucleus.  
	 *
	 * @access public
	 * @return int a status code
	 */
	function save() {
		if ($this->_needToBeSaved) {
			return $this->_storage->save($this);
		}
		return SUCCESS;
	}

	/**
	 * Refresh this item from the persistent store
	 *
	 * @access public
	 * @return int a status code
	 */
	function refresh() {
		$this = $this->_storage->refresh($this);
		return SUCCESS;
	}

	/**
	 * Delete this GalleryNucleus
	 *
	 * Delete this GalleryNucleus and notify its parent GalleryNucleus of
	 * the change.
	 *
	 * @access public
	 * @return int a status code
	 */
	function delete() {
	}
}

/**
 * Base class for all objects in the Gallery composite tree
 *
 * Container for all functionality and data common objects that 
 * Gallery can deal with.  Each GalleryItem has the capacity
 * to own other GalleryItems in a parent-child relationship.
 * That capacity can be enabled or disabled by subclasses of
 * GalleryItem.
 *
 * @version $Id$
 * @module GalleryItem
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class GalleryItem extends GalleryNucleus {

	/*
	 * ****************************************
	 *                 Members
	 * ****************************************
	 */

	/**
	 * The id of the User who owns this item
	 */
	var $_ownerId;

	/**
	 * An ordered list of 0+ Comment ids.
	 */
	var $_commentIds;

	/**
	 * Properties of this GalleryItem
	 *
	 * Valid properties are:
	 * - creationDate	 (string) date in "YYYYMMDDHHMMSS" format
	 *                                (we don't want it limited by the epoch)
	 * - modificationDate	 (int)    unix timestamp
	 * - viewedSinceDate	 (int)    unix timestamp click count start date 
	 * - viewCount		 (int)    number of times this item has been accessed
	 * - keywords 		 (string) key words about this item
	 * - title		 (string) title of this item (short)
	 * - description	 (string) details of this item (long)
	 * - isHtmlAllowed	 (bool)   allow html in the title & description
	 * - isHidden		 (bool)   is this item hidden?
	 * - inheritsPermissions (bool)   does this item inherit permissions from its parents?
	 *
	 * @var array $_properties
	 */
	var $_properties;

	/**
	 * An associative array of item specific properties about this
	 * item.  Each subclass can have an interface to read and
	 * write values into this store (or they can use GalleryItem's
	 * get/set methods).  Either way, this data is item specific.
	 */
	var $_extendedProperties;

	/**
	 * The id of the ImageContainer containing this GalleryItem's thumbnail
	 */
	var $_thumbnailId;

	/**
	 * An ordered list of 0+ GalleryItem children contained by this item
	 *
	 * @var array $_childIds;
	 */
	var $_childIds;

	/*
	 * ****************************************
	 *                 Methods
	 * ****************************************
	 */

	/**
	 * Constructor
	 *
	 * Call the superclass on the id provided.  That will create
	 * either a blank object (if there's no id) or it will load the
	 * appropriate object from the persistent storage.  If no id
	 * was provided, initialize all private variables to their
	 * default values.
	 *
	 * @access public
	 * @param string the id of an object to be loaded
	 */
	function GalleryItem($id="") {
		$this->GalleryNucleus($id);

		if (empty($id)) {
			// Set values to defaults
		}
	}

	/**
	 * Get the list of supported file types
	 *
	 * Get the list of supported file types that this GalleryItem can
	 * support.
	 *
	 * @access public
	 * @return array lowercase file tags tags (eg "jpg", "gif")
	 */
	function getSupportedFiletypes() {
	}
		
	/**
	 * Is this file type supported?
	 *
	 * Is this file type supported?
	 * 
	 * @access public
	 * @param string a file tag (eg "jpg", "Jpg", "JPG", "JPEG")
	 * @return bool true if the tag given is supported 
	 */
	function isSupportedFiletype($tag) {
	}
		
	/**
	 * Update the viewed counter.
	 *
	 * Record the fact that this item has just been viewed.
	 *
	 * @access public
	 */
	function incrementViewed() {
	}

	/**
	 * Add a comment to this GalleryItem
	 *
	 * Add a comment to this GalleryItem
	 *
	 * @access public
	 * @param CommentContainer $comment
	 */
	function addComment($comment) {
	}

	/**
	 * Retrieve the list of Comment ids for this GalleryItem
	 *
	 * Retrieve the list of Comment ids for this GalleryItem
	 *
	 * @access public
	 * @return array an ordered list of ids
	 */
	function getCommentIds() {
	}

	/**
	 * Remove a comment from this Item
	 *
	 * Remove a comment from this Item
	 *
	 * @access public
	 * @param string a comment id
	 */
	function removeComment($id) {
	}

	/**
	 * Return the value of the property with the given key
	 *
	 * Return a copy of the value of the property with the 
	 * given key.
	 *
	 * @access public
	 * @param string a key name
	 * @return mixed a value
	 */
	function getProperty($propertyName) {
	}

	/**
	 * Store the given key/value pair
	 *
	 * Store the given value in the properties map and associate
	 * it with the key provided.
	 *
	 * @access public
	 * @param string a key name
	 * @param mixed a value.
	 */
	function setProperty($propertyName, $value) {
	}

	/**
	 * Remove the given key
	 *
	 * Remove the given key from the properties map.
	 *
	 * @access public
	 * @param string a key name
	 */
	function removeProperty($propertyName) {
	}

	/**
	 * Return the value of the extended property with the given key
	 *
	 * Return a copy of the value of the extended property with
	 * the given key.
	 *
	 * @access public
	 * @param string a key name
	 * @return mixed a value
	 */
	function getExtendedProperty($propertyName) {
	}

	/**
	 * Store the given key/value pair as an extended property
	 *
	 * Store the given value in the extended properties map and
	 * associate it with the key provided.
	 *
	 * @access public
	 * @param string a key name
	 * @param mixed a value.
	 */
	function setExtendedProperty($propertyName, $value) {
	}

	/**
	 * Remove the given key from the extended properties map
	 *
	 * Remove the given key from the extended properties map.
	 *
	 * @access public
	 * @param string a key name
	 */
	function removeExtendedProperty($propertyName) {
	}

	/**
	 * Return the type of this GalleryItem
	 *
	 * Return the type of this GalleryItem
	 *
	 * @access public
	 * @return string the type of this GalleryItem, eg. "Album" or "Photo".
	 */
	function getType() {
	}

	/**
	 * Get the id of the ImageContainer containing the thumbnail for this item
	 *
	 * Get the id of the ImageContainer containing the thumbnail for this item
	 *
	 * @access public
	 * @return string the id of the thumbnail ImageContainer
	 */
	function getThumbnailId() {
	}

	/**
	 * Get the id of the ImageContainer containing the thumbnail for this item
	 *
	 * Get the id of the ImageContainer containing the thumbnail
	 * for this item.
	 *
	 * @access public
	 * @param string id of the ImageContainer containing the thumbnail image
	 */
	function setThumbnailId($id) {
	}

	/**
	 * Can this item contain other items?
	 *
	 * By default, GalleryItems cannot contain other items.  However
	 * Subclasses may wish to override this method to allow
	 * containment.
	 *
	 * @access public
	 * @return bool true if the item can contain children
	 */
	function canContainChildren() {
	}

	/**
	 * How many children does this item and all of its sub-items
	 * contain, including itself?
	 *
	 * If this item can't contain children, the answer is 1, else
	 * it's 1 + the number of immediate children and all their
	 * children, etc, etc.
	 *
	 * @access public
	 * @return int the number of children
	 */
	function getChildCount() {

		// Must track which children have their own permission
		// set so that we can optimize this count process.  Otherwise
		// we'll have to check each child individually
	}

	/**
	 * Get the list of children ids
	 *
	 * If this item is allowed to have children, return the list
	 * of child ids it contains.  Else, return an empty array.
	 *
	 * @access public
	 * @return array a list of 0+ GalleryItem ids
	 */
	function getItemIds() {
	}

	/**
	 * Add a specific item as a child of this item.  
	 *
	 * This is only legal if this item is allowed to have
	 * children.  If the child item already has a parent, it is
	 * removed from that other parent if it's successfully added
	 * to this one.
	 *
	 * Move all DataContainers of the child item from their old
	 * location to the new one as part of this process.
	 *
	 * @access public
	 * @param GalleryItem the child item
	 */
	function addItem($item) {
	}

	/**
	 * Remove the specified child item
	 *
	 * This is only legal if this item is allowed to have children.
	 *
	 * @access public
	 * @param string the child item's id
	 */
	function removeItem($id) {
	}

	/**
	 * Return the id of the User object who owns this GalleryItem
	 *
	 * @access public
	 * @return string the id of the owning user
	 */
	function getOwnerId() {
	}

	/**
	 * Does the user have the given permission?
	 *
	 * This calculation is made taking into account the appropriate
	 * attributes for this user from all of its parents, provided that
	 * they have the inheritsPermissions property set.
	 *
	 * Acceptable permissions are:
	 * PERMISSION_CAN_VIEW     
	 * PERMISSION_CAN_CHANGE   
	 * PERMISSION_CAN_ADD_TO   
	 *
	 * @access public
	 * @param string user id
	 * @param string permission name
	 * @return bool true if the given user id has the given permission for this item
	 */
	function hasPermission($id, $perm) {
	}

	/**
	 * Adjust the user's permissions for this item.
	 *
	 * Adjust the user's permissions for this item to set the permission
	 * provided.  If the permission being set directly contradicts
	 * another one, the old (contradictory) permission is removed.
	 * For example, if the user's permission for this item has
	 * PERMISSION_CANNOT_VIEW set, and you set
	 * PERMISSION_CAN_VIEW, then the result is that the
	 * PERMISSION_CANNOT_VIEW is removed.
	 *
	 * Acceptable permissions are:
	 * PERMISSION_CAN_VIEW     
	 * PERMISSION_CANNOT_VIEW  
	 * PERMISSION_CAN_CHANGE   
	 * PERMISSION_CANNOT_CHANGE
	 * PERMISSION_CAN_ADD_TO   
	 * PERMISSION_CANNOT_ADD_TO
	 *
	 * @access public
	 * @return bool true if the given user id has the given permission for this item
	 */
	function setPermission($id, $perm, $bool) {
	}
}

/**
 * A subclass of GalleryItem for containing groups of GalleryItems
 *
 * A GalleryItem that has certain extra properties relating to
 * displaying item groups and is allowed to contain other
 * GalleryItems.
 *
 * @version $Id$
 * @module AlbumItem
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class AlbumItem extends GalleryItem {
	/*
	 * ****************************************
	 *                 Members
	 * ****************************************
	 */

        Members
	-------
	/**
	 * Properties of this GalleryItem
	 *
	 * Valid properties are:
	 * - bgcolor		(string) primary background color
	 * - bgcolor2		(string) secondary background color
	 * - textcolor		(string) text color
	 * - linkcolor		(string) link color
	 * - font		(string) font name
	 * - border		(string) amount of table border
	 * - bordercolor	(string) color of border
	 * - showBreadcrumb	(string) whether or not to show the breadcrumb links
	 * - thumbSize		(string) target size of the thumbnail
	 * - resizeSize		(string) target size of the intermediate image
	 * - rows		(int)    number of rows to show
	 * - cols		(int)    number of columns to show
	 * - useFullOnly	(bool)   allow the user to choose to show unresized only?
	 * - printService	(bool)   allow printing?
	 * - viewExtendedData	(bool)   allow user to view extended data?
	 * - layout		(string) the layout to use for this album
	 * - htmlHeader		(string) the html_header to use for this album
	 * - htmlFooter		(string) the html_footer to use for this album
	 * - displayViewCount	(bool)   show view counts for my items?
	 */
	
	/*
	 * ****************************************
	 *                 Methods
	 * ****************************************
	 */
	
	/**
	 * Constructor
	 *
	 * Call the superclass on the id provided.  That will create
	 * either a blank object (if there's no id) or it will load the
	 * appropriate object from the persistent storage.  If no id
	 * was provided, initialize all private variables to their
	 * default values.
	 *
	 * @access public
	 * @param string the id of an object to be loaded
	 */
	function AlbumItem($id="") {
		$this->GalleryItem($id);

		if (empty($id)) {
			// Set values to defaults
		}
	}

	/**
	 * Can this item contain other items?
	 *
	 * AlbumItems are allowed to contain other GalleryItems
	 *
	 * @access public
	 * @return bool true if the item can contain children
	 */
	function canHaveChildren() {
		return true;
	}
}

/**
 * A subclass of GalleryItem for items containing actual data
 *
 * DataItems are ones that have an actual data source, such as 
 * PhotoItem or MovieItem.
 *
 * @version $Id$
 * @module DataItem
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class DataItem extends GalleryItem {

	/*
	 * ****************************************
	 *                 Members
	 * ****************************************
	 */

	/**
	 * The DataContainer containing the actual source object for this item,
	 * if applicable.
	 *
	 * @var DataContainer
	 */
	var $_source;

	/*
	 * ****************************************
	 *                 Methods
	 * ****************************************
	 */

	/**
	 * Constructor
	 *
	 * Call the superclass on the id provided.  That will create
	 * either a blank object (if there's no id) or it will load the
	 * appropriate object from the persistent storage.  If no id
	 * was provided, initialize all private variables to their
	 * default values.
	 *
	 * @access public
	 * @param string the id of an object to be loaded
	 */
	function DataItem($id="") {
		$this->GalleryItem($id);

		if (empty($id)) {
			// Set values to defaults
		}
	}

	/**
	 * Set the source of this item to the file provided
	 *
	 * If this item already had a source, replace it with the one
	 * we provide here.  Subclasses should overload this method to
	 * do the appropriate thing when their data source changes.
	 *
	 * @access public
	 * @param string the path to a file
	 */
	function setSourceId($id) {
	}

	/**
	 * Get the source id of this item.
	 *
	 * Return the id of the DataContainer that contains the source
	 * for this item.  For example, if the DataItem is a PhotoItem,
	 * the source is the full size original image.
	 *
	 * @access public
	 * @return string the id of a DataContainer
	 */
	function getSourceId() {
	}
}

/**
 * A subclass of DataItem for containing Photos
 *
 * A GalleryItem whose source is an image.  It contains no image   
 * information itself, but contains several ImageContainer
 * versions of the original.
 *
 * @version $Id$
 * @module PhotoItem
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class PhotoItem extends DataItem {

	/*
	 * ****************************************
	 *                 Members
	 * ****************************************
	 */

	/**
	 * An ordered list of ids of ImageContainers containing
	 * resized versions of the raw image, sorted by
	 * in ascending order by size.
	 *
	 * @var	array
	 */
	var $_resizeIds;

	/*
	 * ****************************************
	 *                 Methods
	 * ****************************************
	 */

	/**
	 * Constructor
	 *
	 * Call the superclass on the id provided.  That will create
	 * either a blank object (if there's no id) or it will load the
	 * appropriate object from the persistent storage.  If no id
	 * was provided, initialize all private variables to their
	 * default values.
	 *
	 * @access public
	 * @param string the id of an object to be loaded
	 */
	function PhotoItem($id="") {
		$this->DataItem($id);

		if (empty($id)) {
			// Set values to defaults
			// Pull in EXIF data, if applicable
			// Set the creation date from the EXIF capture date
		}
	}

	/**
	 * Return an ordered list of resized images
	 *
	 * The list is sorted by image size in ascending order.
	 *
	 * @access public
	 * @return array ids of the resized images.
	 */
	function getResizeIds() {
	}

	/**
	 * Set the specified resize image to the ImageContainer provided.
	 *
	 * If an ImageContainer exists at that index, delete it.
	 *
	 * @access public
	 * @param string the id of the ImageContainer containing the resize
	 */
	function addResizeId($id) {
	}

	/**
	 * Remove the specified resized image
	 *
	 * Remove the specified resized image.
	 * 
	 * @access public
	 * @param int the id of the desired resized image to remove
	 */
	function removeResizeId($id) {
	}
}

/**
 * A subclass of DataItem for containing Movies
 *
 * A GalleryItem whose source is a movie.  It contains no image/movie
 * information itself, but its source is a MovieContainer.
 *
 * @version $Id$
 * @module MovieItem
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class MovieItem extends DataItem {
}

/**
 * A subclass of DataItem for containing unknown objects.
 *
 * These are objects that we know nothing about.  Currently this
 * is exactly the same as a DataItem, although that may change.
 *
 * @version $Id$
 * @module UnknownItem
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class UnknownItem extends DataItem {
}

/**
 * A container for a data source that Gallery manages.
 *
 * A container for any data that Gallery can manage.  Known
 * implementations include ImageContainer, MovieContainer or
 * UnknownContainer.
 *
 * @version $Id$
 * @module DataContainer
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class DataContainer extends GalleryNucleus {

	/*
	 * ****************************************
	 *                 Members
	 * ****************************************
	 */

	/**
	 * The name of the file that contains the actual media data.
	 * This, when combined with the parent's path forms the
	 * complete path to the file.
	 *
	 * @var string
	 */
	var $_dataFileName;

	/**
	 * Is this object derived from another one?  (eg, thumbnails
	 * and resized images)
	 *
	 * @var bool
	 */
	var $_isDerivative;

	/**
	 * What's the source of this derivative?  The source must be
	 * the id of another DataContainer.
	 *
	 * @var int
	 */
	var $_derivativeSource;

	/**
	 * A sequence of commands used to derive this data from the original
	 *
	 * @var int
	 */
	var $_derivativeCommands;


	/*
	 * ****************************************
	 *                 Methods
	 * ****************************************
	 */

	/**
	 * Constructor
	 *
	 * Call the superclass on the id provided.  That will create
	 * either a blank object (if there's no id) or it will load the
	 * appropriate object from the persistent storage.  If no id
	 * was provided, initialize all private variables to their
	 * default values.
	 *
	 * @access public
	 * @param string the id of an object to be loaded
	 */
	function DataContainer($id="", $dataFileName="") {
		$this->GalleryNucleus($id);

		if (empty($id)) {
			// Set values to defaults
			// Make a copy the data file and start managing it
		}
	}

	/**
	 * Get the size of the source object.  If it's a cacheable
	 * object and the cache is cleared, this will return the size
	 * that it *will* be once the cache is recreated.
	 * 
	 * @access public
	 * @return int the size of the object
	 */
	function getSize() {
	}

	/**
	 * Is this item a derivative?
	 *
	 * If an item is a derative object, it can be expired using
	 * the expireCache() method.  You must call rebuildCache() to
	 * recreate the item.
	 * 
	 * @access public
	 * @return bool whether the item is expireable or not
	 */
	function isDerative() {
	}

	/**
	 * What's the source of this derivative?
	 *
	 * Only applicable if isDerative() returns true.
	 * 
	 * @access public
	 * @return int the id of another DataContainer 
	 */
	function getDerivativeSource() {
	}

	/**
	 * What's the source of this derivative?
	 *
	 * Only applicable if isDerative() returns true.
	 * 
	 * @access public
	 * @param int the id of another DataContainer 
	 */
	function setDerivativeSource($id) {
		$this->setNeedToBeSaved();
	}

	/**
	 * Get the commands used to derive this data from its source
	 *
	 * Only applicable if isDerative() returns true.
	 * 
	 * @access public
	 * @return int a derivative type
	 */
	function getDerivativeCommands() {
	}

	/**
	 * Set the commands used to derive this data from its source
	 *
	 * Only applicable if isDerative() returns true.  The commands
	 * follow this EBNF format:
	 *
	 * COMMAND   = <OPERATION> | <COMMAND> ; <COMMAND>
	 * OPERATION = ROTATE | SCALE | RESIZE | CROP
	 * ROTATE    = "rotate" ":" ("-90" | "180" | "90")
	 * CROP      = "crop" ":" NUMBER "," NUMBER "," NUMBER "," NUMBER
	 * RESIZE    = "resize" ":" NUMBER "," NUMBER 
	 * SCALE     = "scale" ":" NUMBER 
	 * 
	 * @access public
	 * @param string a sequence of derivative commands
	 */
	function setDerivativeCommands($commands) {
		$this->setNeedToBeSaved();
	}

	/**
	 * Has this item expired?
	 *
	 * If the item is expired, it can be rebuilt with rebuildCache()
	 * 
	 * @access public
	 * @return bool true if the item is expired (ie, the cache is empty)
	 */
	function isExpired() {
	}

	/**
	 * Expire the cache.
	 * 
	 * @access public
	 * @return int a status code
	 */
	function expireCache() {
	}

	/**
	 * Rebuild the cache.
	 * 
	 * @access public
	 * @return int a status code
	 */
	function rebuildCache() {
	}

	/**
	 * Get the size of the cached data.
	 *
	 * Get the size of the data that we're currently keeping in 
	 * the cache for this source object.  It'll be 0 if the cache
	 * has been cleared.
	 * 
	 * @access public
	 * @return int the size of the cache
	 */
	function getCacheSize() {
	}

	/**
	 * Get name of the data file.
	 *
	 * Get the name of the data file.
	 * 
	 * @access public
	 * @return string the file name
	 */
	function getDataFileName() {
	}

	/**
	 * Get the full path to the data file.
	 *
	 * Get the full path to the data file.
	 * 
	 * @access public
	 * @return string the file path
	 */
	function getDataFilePath() {
	}
}

/**
 * A DataContainer for images
 *
 * A container for a single image.  This image may or may not be
 * cacheable (depending on whether or not it's a derivative image).
 *
 * @version $Id$
 * @module ImageContainer
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class ImageContainer extends DataContainer {

	/*
	 * ****************************************
	 *                 Members
	 * ****************************************
	 */

	/**
	 * The x-axis origin of this image, useful if this is a
	 * derivative image such as a thumbnail from a specific
	 * section of an original image.
	 *
	 * @var	int
	 */
	var $_originX;

	/**
	 * The y-axis origin of this image, useful if this is a
	 * derivative image such as a thumbnail from a specific
	 * section of an original image.
	 *
	 * @var	int
	 */
	var $_originY;

	/**
	 * The width this image.
	 *
	 * @var	int
	 */
	var $_width;

	/**
	 * The height this image.
	 *
	 * @var	int
	 */
	var $_height;

	/**
	 * For derivatives, specify the scaling target.  This is used to rebuild
	 * the image.
	 *
	 * @var	int
	 */
	var $_scalingTarget;

	/*
	 * ****************************************
	 *                 Methods
	 * ****************************************
	 */

	/**
	 * Constructor
	 *
	 * Call the superclass on the id provided.  That will create
	 * either a blank object (if there's no id) or it will load the
	 * appropriate object from the persistent storage.  If no id
	 * was provided, initialize all private variables to their
	 * default values.
	 *
	 * @access public
	 * @param string the id of an object to be loaded
	 */
	function ImageContainer($id="", $dataFileName="") {
		$this->DataContainer($id, $dataFileName);

		if (empty($id)) {
			// Set values to defaults
		}
	}

	/**
	 * Return the width of the image
	 *
	 * Return the width of the image
	 *
	 * @return int the width of the image
	 * @access public
	 */
	function getWidth() {
	}

	/**
	 * Return the height of the image
	 *
	 * Return the height of the image
	 *
	 * @return int the height of the image
	 * @access public
	 */
	function getHeight() {
	}
}

/**
 * A DataContainer for movies
 *
 * A container for a single movie.
 *
 * @version $Id$
 * @module MovieContainer
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class MovieContainer extends DataContainer {

	/*
	 * ****************************************
	 *                 Members
	 * ****************************************
	 */

	/**
	 * The width this movie.
	 *
	 * @var	int
	 */
	var $_width;

	/**
	 * The height this movie.
	 *
	 * @var	int
	 */
	var $_height;

	/*
	 * ****************************************
	 *                 Methods
	 * ****************************************
	 */

	/**
	 * Constructor
	 *
	 * Call the superclass on the id provided.  That will create
	 * either a blank object (if there's no id) or it will load the
	 * appropriate object from the persistent storage.  If no id
	 * was provided, initialize all private variables to their
	 * default values.
	 *
	 * @access public
	 * @param string the id of an object to be loaded
	 */
	function MovieContainer($id="", $dataFileName="") {
		$this->DataContainer($id, $dataFileName);

		if (empty($id)) {
			// Set values to defaults
		}
	}

	/**
	 * Return the width of the movie
	 *
	 * Return the width of the movie
	 *
	 * @return int the width of the movie
	 * @access public
	 */
	function getWidth() {
	}

	/**
	 * Return the height of the movie
	 *
	 * Return the height of the movie
	 *
	 * @return int the height of the movie
	 * @access public
	 */
	function getHeight() {
	}
}

/**
 * A DataContainer for objects that Gallery doesn't understand
 *
 * We can't manipulate these objects in any way.
 *
 * @version $Id$
 * @module UnknownContainer
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class UnknownContainer extends DataContainer {

	/*
	 * ****************************************
	 *                 Members
	 * ****************************************
	 */

	/*
	 * ****************************************
	 *                 Methods
	 * ****************************************
	 */
}

/**
 * A DataContainer for comments.
 *
 * Comments are just structured text objects.
 *
 * @version $Id$
 * @module CommentContainer
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class CommentContainer extends DataContainer {

	/*
	 * ****************************************
	 *                 Members
	 * ****************************************
	 */
	var $_name;
	var $_emailAddress;
	var $_hostname;
	var $_comment;
	var $_date;

	/*
	 * ****************************************
	 *                 Methods
	 * ****************************************
	 */

	/**
	 * Constructor
	 *
	 * Call the superclass on the id provided.  That will create
	 * either a blank object (if there's no id) or it will load the
	 * appropriate object from the persistent storage.  If no id
	 * was provided, initialize all private variables to their
	 * default values.
	 *
	 * @access public
	 * @param string the id of an object to be loaded
	 */
	function CommentContainer($id="") {
		$this->DataContainer($id);

		if (empty($id)) {
			// Set values to defaults
		}
	}

	/**
	 * Get the name
	 *
	 * Get the name
	 *
	 * @access public
	 * @return string the name from the comment
	 */
	function getName() {
	}

	/**
	 * Set the name
	 *
	 * Set the name
	 *
	 * @access public
	 * @param string the name for the comment
	 */
	function setName($name) {
	}

	/**
	 * Get the email address
	 *
	 * Get the email address
	 *
	 * @access public
	 * @return string the email address from the comment
	 */
	function getEmailAddress() {
	}

	/**
	 * Set the email address
	 *
	 * Set the email address
	 *
	 * @access public
	 * @param string the email address for the comment
	 */
	function setEmailAddress($email) {
	}

	/**
	 * Get the hostname
	 *
	 * Get the hostname
	 *
	 * @access public
	 * @return string the hostname from the comment
	 */
	function getHostname() {
	}

	/**
	 * Set the hostname
	 *
	 * Set the hostname
	 *
	 * @access public
	 * @param string the hostname for the comment
	 */
	function setHostname($hostname) {
	}

	/**
	 * Get the comment
	 *
	 * Get the comment
	 *
	 * @access public
	 * @return string the comment from the comment
	 */
	function getComment() {
	}

	/**
	 * Set the comment
	 *
	 * Set the comment
	 *
	 * @access public
	 * @param string the comment for the comment
	 */
	function setComment($comment) {
	}

	/**
	 * Get the date
	 *
	 * Get the date
	 *
	 * @access public
	 * @return string the date from the comment
	 */
	function getDate() {
	}

	/**
	 * Set the date
	 *
	 * Set the date
	 *
	 * @access public
	 * @param string the date for the comment
	 */
	function setDate($date) {
	}
}

/**
 * A toolkit for manipulating images
 *
 * This class defines the API for image toolkits.  Subclasses should
 * implement this for a specific image toolkit, such as NetPBM or
 * ImageMagick.
 *
 * @version $Id$
 * @module GalleryImageToolkit
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class GalleryImageToolKit {
	/*
	 * ****************************************
	 *                 Methods
	 * ****************************************
	 */

	/**
	 * Get the list of supported file types
	 *
	 * Get the list of supported file types that this toolkit can
	 * support.
	 *
	 * @access public
	 * @return array lowercase file tags tags (eg "jpg", "gif")
	 */
	function getSupportedFileTypes() {
	}
		
	/**
	 * Is this file type supported?
	 *
	 * Is this file type supported?
	 * 
	 * @access public
	 * @param string a file tag (eg "jpg", "Jpg", "JPG", "JPEG")
	 * @return bool true if the tag given is supported 
	 */
	function isSupportedFiletype($tag) {
	}
		
	/**
	 * Calculate the dimensions of the image file
	 *
	 * Calculate the dimensions of the image file
	 * 
	 * @access public
	 * @param string a file name
	 * @return array the width, height of the image
	 */
	function getImageDimensions($filename) {
	}

	/**
	 * Resize the image to the target size specified
	 *
	 * Resize the image located at sourceFilename and write the results in      
	 * destFilename.  Resize the image to the dimensions provided, ignoring
	 * changes to the aspect ratio.
	 *	
	 * @access public
	 * @param string the source file name
	 * @param string the destination file name (it will be overwritten if it exists)
	 * @param string int the target size
	 * @return int a status code
	 */
	function resizeImage($sourceFilename, $destFilename, $width, $height) {
	}
		
	/**
	 * Scale the image to the target size specified
	 *
	 * Resize the image located at sourceFilename and write the results in      
	 * destFilename.  Scale the image such that it fits within the bounding
	 * box specified by $targetSize x $targetSize, while maintaining the
	 * aspect ratio.
	 *	
	 * @access public
	 * @param string the source file name
	 * @param string the destination file name (it will be overwritten if it exists)
	 * @param string int the target size
	 * @return int a status code
	 */
	function scaleImage($sourceFilename, $destFilename, $targetSize) {
	}
		
	/**
	 * Rotate the image by the degrees specified
	 *
	 * Rotate the image located at sourceFilename and write the results in      
	 * destFilename.
	 *	
	 * @access public
	 * @param string the source file name
	 * @param string the destination file name (it will be overwritten if it exists)
	 * @param string int the degrees to be rotated (one of -90, 180, 90)
	 * @return int a status code
	 */
	function rotateImage($sourceFilename, $destFilename, $degrees) {
	}
		
	/**
	 * Crop the image by the position and dimensions specified
	 *
	 * Crop the image located at sourceFilename and write the results in 
	 * destFilename.  The upper left corner of the subsection is
	 * at the x, y coordinate provided and the lower right is
	 * x+width, y+height.
	 *	
	 * @access public
	 * @param string the source file name
	 * @param string the destination file name (it will be overwritten if it exists)
	 * @param int x-axis origin
	 * @param int y-axis origin
	 * @param int width of crop rectangle
	 * @param int height of crop rectangle
	 * @return int a status code
	 */
	function cropImage($sourceFilename, $destFilename, $x, $y, $width, $height) {
	}

	/**
	 * Is this image valid?
	 *
	 * Is this image valid?  Can it be handled by this toolkit?
	 * 
	 * @access public
	 * @param string the image file name
	 * @return boolean true if the filename represents an image file
	 */
	function isValidImage($filename) {
	}

	/**
	 * Get any extended image properties associated with this image
	 *
	 * Some file types have embedded data.  Eg, JPEG can have EXIF
	 * data.
	 * 
	 * @access public
	 * @param string the image file name
	 * @return array a set of key value pairs
	 */
	function getExtendedProperties($filename) {
	}
}

Implementations
---------------
	ImageToolKit/NetPbm.class
	ImageToolKit/ImageMagick.class

/**
 * Access to a repository of GalleryUser objects
 *
 * This is an abstract class that provides access to the database of
 * User objects.  It must be implemented by a class that can save and
 * restore User objects from a persistent store.  The features of the
 * UserDatabase implementation vary depending on where Gallery is
 * used, so the UserDatabase needs to be able to specify it's
 * available feature set. For example, if you're using Gallery inside
 * an embedded app like Nuke, then the NukeUserDatabase should not
 * allow you to add and delete users from the database (let the Nuke
 * application take care of that, instead).
 *
 * @version $Id$
 * @module GalleryUserDatabase
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */
class GalleryUserDatabase {

	/*
	 * ****************************************
	 *                 Methods
	 * ****************************************
	 */

	/**
	 * Can you create a user using this implementation?
	 *
	 * Can you create a user using this implementation?
	 * 
	 * @access public
	 * @return bool true or false
	 */
	function canCreateUser() {
	}

	/**
	 * Can you modify a user using this implementation?
	 *
	 * Can you modify a user using this implementation?
	 * 
	 * @access public
	 * @return bool true or false
	 */
	function canModifyUser() {
	}

	/**
	 * Can you delete a user using this implementation?
	 *
	 * Can you delete a user using this implementation?
	 * 
	 * @access public
	 * @return bool true or false
	 */
	function canDeleteUser() {
	}

	/**
	 * Get the "nobody" pseudo-user
	 *
	 * Get the "nobody" pseudo-user
	 * 
	 * @access public
	 * @return GalleryUser
	 */
	function getNobodyUser() {
	}

	/**
	 * Get the "everybody" pseudo-user
	 *
	 * Get the "everybody" pseudo-user
	 * 
	 * @access public
	 * @return GalleryUser
	 */
	function getEverybodyUser() {
	}

	/**
	 * Get the "authenticated" pseudo-user
	 *
	 * Get the "authenticated" pseudo-user
	 * 
	 * @access public
	 * @return GalleryUser
	 */
	function getAuthenticatedUser() {
	}

	/**
	 * Get the number of users in the database
	 *
	 * Get the number of users in the database
	 * 
	 * @access public
	 * @return int the number of users
	 */
	function getNumberOfUsers() {
	}

	/**
	 * Get the ids of users in the given range
	 *
	 * Get the ids of users in the given range
	 * 
	 * @access public
	 * @param int start of the range (inclusive)
	 * @param int end of the range (inclusive)
	 * @return array user ids
	 */
	function getUserIds($start, $end) {
	}

	/**
	 * Get the GalleryUser for the id specified
	 *
	 * Get the GalleryUser for the id specified
	 * 
	 * @access public
	 * @param string id of the user desired
	 * @return GalleryUser the user
	 */
	function &getUserById($id) {
	}

	/**
	 * Get the GalleryUser for the username specified
	 *
	 * Get the GalleryUser for the username specified
	 * 
	 * @access public
	 * @param string username of the user desired
	 * @return GalleryUser the user
	 */
	function &getUserByUsername($username) {
	}
}

Implementations
---------------
	GalleryUserDatabase/GalleryFileSystem.class
	GalleryUserDatabase/GalleryMySQL.class

/**
 * Representation of a single user
 * 
 * This class is the container for information about Gallery     
 * users.  Each instance of User contains a unique user id. It   
 * must be implemented by a class that has a persistent store for
 * the relevant user data.
 * 
 * @version $Id$
 * @module GalleryUser
 * @modulegroup core
 * @package Gallery
 * @author Bharat Mediratta <bharat@menalto.com>
 */

class GalleryUser extends GalleryNucleus {
	
	/*
	 * ****************************************
	 *                 Members
	 * ****************************************
	 */

	/**
	 * The User's username
	 *
	 * @var	string
	 */
	var $_username;

	/**
	 * The User's full name
	 *
	 * @var	string
	 */
	var $_fullname;

	/**
	 * The User's password in a hashed form.
	 *
	 * @var	string
	 */
	var $_password;

	/**
	 * The User's email address.
	 *
	 * @var	string
	 */
	var $_email;

	/**
	 * Is the user a Gallery admininstrator?
	 *
	 * @var	boolean
	 */
	var $_isAdmin;

	/*
	 * ****************************************
	 *                 Methods
	 * ****************************************
	 */

	/**
	 * Constructor
	 *
	 * Call the superclass on the id provided.  That will create
	 * either a blank object (if there's no id) or it will load the
	 * appropriate object from the persistent storage.  If no id
	 * was provided, initialize all private variables to their
	 * default values.
	 *
	 * @access public
	 * @param string the id of an object to be loaded
	 */
	function GalleryUser($id="") {
		$this->GalleryNucleus($id);

		if (empty($id)) {
			// Set values to defaults
		}
	}

	/**
	 * Set the user's password
	 *
	 * Set the user's password
	 *
	 * @param string the new password (in plain text)
	 */
	function setPassword($password) {
	}

	/**
	 * Is the password provided correct?
	 *
	 * @param string a password
	 * @return bool true or false
	 */
	function isCorrectPassword($password) {
	}

	/**
	 * Get the User's id
	 *
	 * @return string the id
	 */
	function getId() {
	}

	/**
	 * Set the User's username
	 *
	 * @param string the new username
	 */
	function setUsername($username) {
	}

	/**
	 * Get the User's username
	 *
	 * @return string the username
	 */
	function getUsername() {
	}

	/**
	 * Set the User's email address
	 *
	 * @param string the new email address
	 */
	function setEmailAddress($email) {
	}

	/**
	 * Get the User's email address
	 *
	 * @param
	 * @return
	 */
	function getEmailAddress()

	/**
	 * Set the User's full name
	 *
	 * @param string the new full name
	 */
	function setFullName($fullname) {
	}

	/**
	 * Get the User's full name
	 *
	 * @return string the user's full name
	 */
	function getFullName() {
	}

	/**
	 * Is this User a Gallery administrator?
	 *
	 * @return bool true or false
	 */
	function isAdmin() {
	}

	/**
	 * Specify that this user is (is not) a Gallery administrator
	 *
	 * @param bool true for adminstrator, false if not
	 */
	function setIsAdmin($yesOrNo) {
	}

	/**
	 * Is this User a pseudo user?
	 *
	 * @return bool true or false
	 */
	function isPseudo() {
	}

}

Implementations
---------------
RegisteredUser
	This is a PseudoUser that represents a user that is logged in.
	It overrides the following methods in PseudoUser:

	- string getUsername()
		* return "REGISTERED"

	- string getFullname()
		* return "A registered user"

	- string getUid() 
		* return "registered"	

EverybodyUser
	This is a PseudoUser that represents any user. It overrides
	the following methods in PseudoUser:

	- string getUsername()
		* return "EVERYBODY"

	- string getFullname()
		* return "Anonymous User"

	- string getUid() 
		* return "everybody"	


NobodyUser
	This is a PseudoUser that represents no user.  It overrides
	the following methods in PseudoUser:

	- string getUsername()
		* return "NOBODY"

	- string getFullname()
		* return "Nobody"

	- string getUid() 
		* return "nobody"	


================================================================================
Constants
================================================================================

  /* Status codes */
  SUCCESS     = 0x00000000
  ERROR       = 0x00000001
  E_IN_USE    = 0x00000010	
  E_DELETED   = 0x00000100
  E_COLLISION = 0x00001000

  /* Permissions */
  PERMISSION_CAN_VIEW 		= 0x01
  PERMISSION_CANNOT_VIEW  	= 0x02
  PERMISSION_CAN_CHANGE   	= 0x03
  PERMISSION_CANNOT_CHANGE	= 0x04
  PERMISSION_CAN_ADD_TO   	= 0x05
  PERMISSION_CANNOT_ADD_TO	= 0x06

================================================================================
Examples
================================================================================

ALBUMS
------

Get the root AlbumItem.  Note that we're assigning by reference


	$rootAlbumId = $gallery->getRootAlbumItemId();
	$rootAlbum =& $gallery->getItemById($rootAlbumId);

Create a new album at the top level with a title and set the
isHtmlAllowed property. 

	$newAlbum = GalleryItemFactory::newAlbumItem();
	$newAlbum->setProperty("title", "This is my new album");
	$newAlbum->setProperty("isHtmlAllowed", true);

	// Lock the root album
	if ($gallery->lock(array(&$rootAlbum))) {
		// Add the item and save it
		$rootAlbum->addItem($newAlbum);
		$rootAlbum->save();

		// Release the lock
		$gallery->unlock();
	} else {
		// FAIL!
	}

Translate a path into an item, load the item and identify its
type.  No need to lock, because we're not saving it.
	$id = $gallery->getIdByPath("/birthdays/mike/picture3");
	$item =& $gallery->getItemById($id);

	if (!empty($item)) {
		// This is the item requested
	} else {
		// The path provided was bad
	}

	$type = $item->getType();
	// e.g., $type is now "Album", "Photo", etc

Can the current user view an item?  Again, no need to lock.

	$id = $gallery->getActiveUserId();
	$userdb =& $gallery->getUserDatabase();
	$user =& $userdb->getUserById($id);
	if ($item->hasPermission($id, PERMISSION_CAN_VIEW)) {
		// Good
	} else {
		// Bad
	}


GENERAL ITEMS (photos, movies, etc)
-----------------------------------
Traverse the list of photos (or whatever else is contained
in a GalleryItem).

	$album = // an AlbumItem
	$itemIds = $album->getItemIds();
	foreach ($itemIds as $id) {
		$item =& $gallery->getItemById($id);
		$type = $item->getType();
		// e.g., $type is now "Album" or "Photo", etc
	}

Get the thumbnail for an item and learn its dimensions:

	$item = // a GalleryItem
	$id = $item->getThumbnailId();
	$image =& $gallery->getDataContainerById($id);
	list($width, $height) = $image->getDimensions();

ITEM CREATION
-------------

Find out what types of files our graphics toolkit can handle:

	$toolkit =& $gallery->getImageToolkit();
	$types = $toolkit->getSupportedFileTypes();

Create a new GalleryItem out of a file just uploaded from a browser.
We get the $name and $path values from PHP as part of the file-upload
feature:

	$path = "/tmp/php712a3u";
	$name = "foo.jpg";
	$item = GalleryItemFactory::createItem($path, $name);
	// $item->getType() == "Photo"

	$path = "/tmp/php712a3u";
	$name = "foo.xxx";
	$item2 = GalleryItemFactory::createItem($path, $name);
	// $item2->getType() == "Unknown"

At this point, $item is now in a temporary holding bin.  Let's add it
to an existing album:

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$album))) {
		$album->addItem($item);
		$gallery->unlock();
	} else {
		// FAIL!
	}

Create a resized version of the image targetted to fit within a 
800x800 bounding box:

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$item))) {

		// First get the id of the source image container
		$sourceId = $item->getSourceId();

		// Then create a new image container and set it's 
		// source accordingly
		$destImageContainer = new ImageContainer();
		$destImageContainer->setDerivativeSource($sourceId);

		// Now specify a target size
		$destImageContainer->setDerivativeCommands("scale:800");
		$destImageContainer->save();

		// Finally, add the image as a resized image to the
		// original item.
		$item->addResizeId($destImageContainer->getId());

		// At this point the image hasn't been created, but it
		// will be the next time it's accessed.  You can trigger
		// a rebuild right now by doing:
		$destImageContainer->rebuildCache();

		$gallery->unlock();
	} else {
		// FAIL!
	}

Change the above resized image to be permanently sized to 200x400.

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$imageContainer))) {
		$ids = $item->getResizeIds();
		$id = $ids[0];  // arbitrary choice here

		// We're unable to acquire the imageContainer's lock here
		// since we can only have one lockset at any given time.
		// however, since we have the parent item's lock we're OK
		$imageContainer =& $gallery->getItemById($id);
		$imageContainer->setDerivativeCommands("resize:200,400");
		$imageContainer->save();
		$imageContainer->expireCache();

		$gallery->unlock();
	} else {
		// FAIL!
	}

Delete the above resized image:

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$imageContainer, &$item))) {
		$ids = $item->getResizeIds();
		$id = $ids[0];  // arbitrary choice here
		$imageContainer =& $gallery->getItemById($id);

		$item->removeResizeId($id);
		$item->save();
		$imageContainer->delete();

		$gallery->unlock();
	} else {
		// FAIL!
	}

Associate a thumbnail with an AlbumItem (ie, make a highlight) from a
PhotoItem's source:

	$photoItem = // a PhotoItem
	$albumItem = // an AlbumItem

	$sourceId = $photoItem->getSourceId();

	// Thumb doesn't need to be locked, as it's a new item
	$thumb = new ImageContainer();
	$thumb->setDerivativeSource($sourceId);
	$destImageContainer->setDerivativeCommands("scale:200");
	$thumb->save();

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$albumItem))) {
		$oldThumbId = $albumItem->getThumbnailId();
		$albumItem->setThumbnailId($thumb->getId();)
		$albumItem->save();
		$gallery->unlock();

		// Delete the old thumbnail, if it exists
		if (!empty($oldThumbId)) {
			$oldThumb =& $gallery->getDataContainerById($oldThumbId);
			if ($gallery->lock(array(&$oldThumbId))) {
				$oldThumb->delete();
				$gallery->unlock();
			}
		}
	} else {
		// FAIL!
	}

Rotate a source image:

XXX Haven't yet decided if we're going to do this by using derivatives
    or by replacing the source image with the rotated version.


COMMENTS
--------
Create a new comment and add it to an item:
	
	$comment = new CommentContainer();
	$comment->setName("John Doe");
	$comment->setEmail("john@doe.com");
	$comment->setComment("This is a comment");

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$albumItem))) {
		$item->addComment($comment);
		$gallery->unlock();
	} else {
		// FAIL!
	}

View all comments:
	$commentIds = $item->getCommentIds();
	foreach ($commentIds as $id) {
		$comment = $item->getComment($id);
		print($comment->getComment());
	}

Remove a comment:
	$id = // id of the comment to be removed
	$comment = $item->getComment($id);

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$albumItem, &$comment))) {
		$item->removeComment($id);
		$item->save();
		$comment->delete();
		$gallery->unlock();
	} else {
		// FAIL!
	}

Move a comment:
	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$oldItem, &$newItem, &$comment))) {
		$id = // id of comment to be moved
		$oldItem->removeComment($id);
		$newItem->addComment($id);
	
		$comment->save();
		$oldItem->save();
		$newItem->save();
	
		$gallery->unlock();
	} else {
		// FAIL!
	}

Edit a comment:
	$id = // id of comment to be editted

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$comment))) {
		$comment->setName("GI Joan");
		$comment->setComment("This is a nice example");
		$comment->save();

		$gallery->unlock();
	} else {
		// FAIL!
	}

