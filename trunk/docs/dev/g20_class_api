Gallery v2.0 Class API
----------------------
$Id$

This is a draft of the class API for Gallery v2.0.  It contains a
sketch of the class hierarchy for the classes that contain the image
metadata.  In writing this API, I've tried to maintain all the
existing functionality that's available in v1.0 while leaving plenty
of room to expand and cover the features that are yet to come in v2.0.

The following functionality is not (yet) implemented in v2.0.

- fitToWindow
	This is gone entirely.  We should be able to implement this
	using the new layout code.

- mirroring
	I've left this out for now because it's heavily dependant on
	the way that we implement the image firewalling code.  I
	believe that this will be possible to add later, once we
	settle on how we do the image firewall.

- the canDeleteFrom permission -- anybody you trust to delete from an
  album you might as well give full write permission

Things that need to be added to this API:
-----------------------------------------
- Sorting!
- Support for some kind of LinkItem (ie, a shared item?)
- Support for user groups

Things that need to be documented more thoroughly in general:
-------------------------------------------------------------
- How permissions work.  Thumbnail sketch: you ask an item if a
  specific user has PERMISSION_CAN_BLAH or PERMISSION_CANNOT_BLAH.
  That item recursively asks it's ancestors for an answer.  We're
  looking for the first parent that has an answer that matches (ie, if
  you're checking the "view full" permission you're looking for the
  user to be on the CAN_VIEW_FULL or CANNOT_VIEW_FULL list, and
  failing that you're looking for Everybody, Nobody or RegisteredUser
  to be on one of those lists).  If no determination can be made, the
  default is CANNOT.

- status codes.  This is mostly in place.  Any time you attempt an
  operation that will actually commit data to the persistent store, you
  can either get a value of SUCCESS, or you can get ERROR.  We may
  eventually want to return bitflags to specify what kind of error
  occurred.

- Creating a new persistence backend (ie, "Filesystem", "MySQL")
  This is not finalized yet.  But I'm thinking that all you need to do is
  to implement a GalleryStorage and GalleryUserDatabase for your
  backend.  The config wizard will instruct the init code to create
  the appropriate GalleryStorage object and store it in the Gallery
  instance.

================================================================================
Examples
================================================================================

ALBUMS
------
Create the root AlbumItem.  This is something that only the config
wizard should do.  It should store the id of the root in config.php
when it's ready.  The config wizard can try this every time, as only
one album can become the root album.

	$rootAlbum = new AlbumItem();
	$status = $rootAlbum->becomeTheRootAlbum();
	if ($status == SUCCESS) {
		$rootAlbum->save();
	} else {
		$rootAlbum->delete();
	}

Get the root AlbumItem.  Note that we're assigning by reference

	$rootAlbumId = $gallery->getRootAlbumItemId();
	$rootAlbum =& $gallery->getItemById($rootAlbumId);

Create a new album at the top level with a title and set the
isHtmlAllowed property. 

	$newAlbum = new AlbumItem();
	$newAlbum->setProperty("title", "This is my new album");
	$newAlbum->setProperty("isHtmlAllowed", true);

	// Lock the root album
	if ($gallery->lock(array(&$rootAlbum))) {
		// Add the item and save it
		$rootAlbum->addItem($newAlbum);
		$rootAlbum->save();

		// Release the lock
		$gallery->unlock();
	} else {
		// FAIL!
	}

Translate a path into an item, load the item and identify its
type.  No need to lock, because we're not saving it.
	$id = $gallery->getIdByPath("/birthdays/mike/picture3");
	$item =& $gallery->getItemById($id);

	if (!empty($item)) {
		// This is the item requested
	} else {
		// The path provided was bad
	}

	$type = $item->getType();
	// e.g., $type is now "Album", "Photo", etc

Can the current user view an item?  Again, no need to lock.

	$id = $gallery->getActiveUserId();
	$userdb =& $gallery->getUserDatabase();
	$user =& $userdb->getUserById($id);
	if ($item->hasPermission($id, PERMISSION_CAN_VIEW)) {
		// Good
	} else {
		// Bad
	}


GENERAL ITEMS (photos, movies, etc)
-----------------------------------
Traverse the list of photos (or whatever else is contained
in a GalleryItem).

	$album = // an AlbumItem
	$itemIds = $album->getItemIds();
	foreach ($itemIds as $id) {
		$item =& $gallery->getItemById($id);
		$type = $item->getType();
		// e.g., $type is now "Album" or "Photo", etc
	}

Get the thumbnail for an item and learn its dimensions:

	$item = // a GalleryItem
	$id = $item->getThumbnailId();
	$image =& $gallery->getContainerById($id);
	list($width, $height) = $image->getDimensions();

ITEM CREATION
-------------

Find out what types of files our graphics toolkit can handle:

	$toolkit =& $gallery->getImageToolkit();
	$types = $toolkit->getSupportedFileTypes();

Create a new GalleryItem out of a file just uploaded from a browser.
We get the $name and $path values from PHP as part of the file-upload
feature:

	$path = "/tmp/php712a3u";
	$name = "foo.jpg";
	$item = GalleryItemFactory::createItem($path, $name);
	// $item->getType() == "Photo"

	$path = "/tmp/php712a3u";
	$name = "foo.xxx";
	$item2 = GalleryItemFactory::createItem($path, $name);
	// $item2->getType() == "Unknown"

At this point, $item is now in a temporary holding bin.  Let's add it
to an existing album:

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$album))) {
		$album->addItem($item);
		$gallery->unlock();
	} else {
		// FAIL!
	}

Create a resized version of the image targetted to fit within a 
800x800 bounding box:

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$item))) {

		// First get the id of the source image container
		$sourceId = $item->getSourceId();

		// Then create a new image container and set it's 
		// source accordingly
		$destImageContainer = new ImageContainer();
		$destImageContainer->setDerivativeSource($sourceId);

		// Now specify a target size
		$destImageContainer->setDerivativeCommands("scale:800");
		$destImageContainer->save();

		// Finally, add the image as a resized image to the
		// original item.
		$item->addResizeId($destImageContainer->getId());

		// At this point the image hasn't been created, but it
		// will be the next time it's accessed.  You can trigger
		// a rebuild right now by doing:
		$destImageContainer->rebuildCache();

		$gallery->unlock();
	} else {
		// FAIL!
	}

Change the above resized image to be permanently sized to 200x400.

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$imageContainer))) {
		$ids = $item->getResizeIds();
		$id = $ids[0];  // arbitrary choice here

		// We're unable to acquire the imageContainer's lock here
		// since we can only have one lockset at any given time.
		// however, since we have the parent item's lock we're OK
		$imageContainer =& $gallery->getItemById($id);
		$imageContainer->setDerivativeCommands("resize:200,400");
		$imageContainer->save();
		$imageContainer->expireCache();

		$gallery->unlock();
	} else {
		// FAIL!
	}

Delete the above resized image:

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$imageContainer, &$item))) {
		$ids = $item->getResizeIds();
		$id = $ids[0];  // arbitrary choice here
		$imageContainer =& $gallery->getContainerById($id);

		$item->removeResizeId($id);
		$item->save();
		$imageContainer->delete();

		$gallery->unlock();
	} else {
		// FAIL!
	}

Associate a thumbnail with an AlbumItem (ie, make a highlight) from a
PhotoItem's source:

	$photoItem = // a PhotoItem
	$albumItem = // an AlbumItem

	$sourceId = $photoItem->getSourceId();

	// Thumb doesn't need to be locked, as it's a new item
	$thumb = new ImageContainer();
	$thumb->setDerivativeSource($sourceId);
	$thumb->setDerivativeCommands("scale:200");
	$thumb->save();

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$albumItem))) {
		$oldThumbId = $albumItem->getThumbnailId();
		$albumItem->setThumbnailId($thumb->getId();)
		$albumItem->save();
		$gallery->unlock();

		// Delete the old thumbnail, if it exists
		if (!empty($oldThumbId)) {
			$oldThumb =& $gallery->getContainerById($oldThumbId);
			if ($gallery->lock(array(&$oldThumbId))) {
				$oldThumb->delete();
				$gallery->unlock();
			}
		}
	} else {
		// FAIL!
	}

Rotate a source image.  Rotations are tricky.  In v1.x we did it by
modifying the original file. This has nasty side effects, such as
losing the EXIF data, potentially corrupting the file, changing the
quality due to lossiness, etc.  In 2.x we do it via derivatives which
avoids all these complications.  Each DataContainer can have two
sources: the "original" source and the "preferred" source.  The
"preferred" source in this case would be a rotated derivative from the
original.  All derivatives from the this item should use the preferred
source so that the thumbnails/resizes come from rotated image.

	$photoItem = // a PhotoItem
	$sourceId = $photoItem->getSourceId();

	$rotated = new ImageContainer();
	$rotated->setDerivativeSource($sourceId);
	$rotated->setDerivativeCommands("rotate:90");
	$rotated->save();

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$photoItem))) {
		$oldId = $photoItem->getPreferredSource();
		$photoItem->setPreferredSource($rotated->getId());
		$gallery->unlock();
	}

	if (!empty($oldId)) {
		$oldData =& $gallery->getContainer($oldId);

		// Acquire the appropriate lock(s)
		if ($gallery->lock(array(&$oldData))) {
			$oldData->delete();
			$gallery->unlock();
		}
	}


COMMENTS
--------
Create a new comment and add it to an item:
	
	$comment = new CommentContainer();
	$comment->setName("John Doe");
	$comment->setEmail("john@doe.com");
	$comment->setComment("This is a comment");

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$albumItem))) {
		$item->addComment($comment);
		$gallery->unlock();
	} else {
		// FAIL!
	}

View all comments:
	$commentIds = $item->getCommentIds();
	foreach ($commentIds as $id) {
		$comment = $item->getComment($id);
		print($comment->getComment());
	}

Remove a comment:
	$id = // id of the comment to be removed
	$comment = $item->getComment($id);

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$albumItem, &$comment))) {
		$item->removeComment($id);
		$item->save();
		$comment->delete();
		$gallery->unlock();
	} else {
		// FAIL!
	}

Move a comment:
	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$oldItem, &$newItem, &$comment))) {
		$id = // id of comment to be moved
		$oldItem->removeComment($id);
		$newItem->addComment($id);
	
		$comment->save();
		$oldItem->save();
		$newItem->save();
	
		$gallery->unlock();
	} else {
		// FAIL!
	}

Edit a comment:
	$id = // id of comment to be editted

	// Acquire the appropriate lock(s)
	if ($gallery->lock(array(&$comment))) {
		$comment->setName("GI Joan");
		$comment->setComment("This is a nice example");
		$comment->save();

		$gallery->unlock();
	} else {
		// FAIL!
	}

================================================================================
Classes
================================================================================

The Class API is now available through the PHPDoc'd version of the source.  
You can either generate the PHPDoc yourself, or you can see an up-to-the-day
version of it at:

	http://jpmullan.com/galleryupdates/docs

